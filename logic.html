
<!DOCTYPE html>

<html>
  <head>
    <meta charset="ascii" />
    <title>3. Logic &#8212; Mathematics in Lean 0.1 documentation</title>
    <link rel="stylesheet" href="_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/language_data.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="shortcut icon" href="_static/favicon.ico"/>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="prev" title="2. Basics" href="basics.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <div class="section" id="logic">
<span id="id1"></span><h1><span class="section-number">3. </span>Logic<a class="headerlink" href="#logic" title="Permalink to this headline">&#182;</a></h1>
<p>In the last chapter, we dealt with equations, inequalities,
and basic mathematical statements like
&#8220;<span class="math notranslate nohighlight">\(x\)</span> divides <span class="math notranslate nohighlight">\(y\)</span>.&#8221;
Complex mathematical statements are built up from
simple ones like these
using logical terms like &#8220;and,&#8221; &#8220;or,&#8221; &#8220;not,&#8221; and
&#8220;if &#8230; then,&#8221; &#8220;every,&#8221; and &#8220;some.&#8221;
In this chapter, we show you how to work with statements
that are built up in this way.</p>
<div class="section" id="implication-and-the-universal-quantifier">
<span id="id2"></span><h2><span class="section-number">3.1. </span>Implication and the Universal Quantifier<a class="headerlink" href="#implication-and-the-universal-quantifier" title="Permalink to this headline">&#182;</a></h2>
<p>Consider the statement after the <code class="docutils literal notranslate"><span class="pre">#check</span></code>:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=import%20data.real.basic%0A%0A--%20BEGIN%0A%23check%20%E2%88%80%20x%20y%20%CE%B5%20%3A%20%E2%84%9D%2C%0A%20%200%20%3C%20%CE%B5%20%E2%86%92%20%CE%B5%20%E2%89%A4%201%20%E2%86%92%20abs%20x%20%3C%20%CE%B5%20%E2%86%92%20abs%20y%20%3C%20%CE%B5%20%E2%86%92%20abs%20(x%20*%20y)%20%3C%20%CE%B5%0A--%20END" target="_blank" tryitfile="../examples/logic/unnamed_24.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span class="k">#check</span> <span class="bp">&#8704;</span> <span class="n">x</span> <span class="n">y</span> <span class="n">&#949;</span> <span class="o">:</span> <span class="n">&#8477;</span><span class="o">,</span>
  <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">&#949;</span> <span class="bp">&#8594;</span> <span class="n">&#949;</span> <span class="bp">&#8804;</span> <span class="mi">1</span> <span class="bp">&#8594;</span> <span class="n">abs</span> <span class="n">x</span> <span class="bp">&lt;</span> <span class="n">&#949;</span> <span class="bp">&#8594;</span> <span class="n">abs</span> <span class="n">y</span> <span class="bp">&lt;</span> <span class="n">&#949;</span> <span class="bp">&#8594;</span> <span class="n">abs</span> <span class="o">(</span><span class="n">x</span> <span class="bp">*</span> <span class="n">y</span><span class="o">)</span> <span class="bp">&lt;</span> <span class="n">&#949;</span>
</pre></div>
</div>
</div><p>In words, we would say &#8220;for every <code class="docutils literal notranslate"><span class="pre">x</span></code>, <code class="docutils literal notranslate"><span class="pre">y</span></code>, and <code class="docutils literal notranslate"><span class="pre">&#949;</span></code>,
if <code class="docutils literal notranslate"><span class="pre">0</span> <span class="pre">&lt;</span> <span class="pre">&#949;</span> <span class="pre">&#8804;</span> <span class="pre">1</span></code>, the absolute value of <code class="docutils literal notranslate"><span class="pre">x</span></code> is less than <code class="docutils literal notranslate"><span class="pre">&#949;</span></code>,
and the absolute value of <code class="docutils literal notranslate"><span class="pre">y</span></code> is less than <code class="docutils literal notranslate"><span class="pre">&#949;</span></code>,
then the absolute value of <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">*</span> <span class="pre">y</span></code> is less than <code class="docutils literal notranslate"><span class="pre">&#949;</span></code>.&#8221;
In Lean, in a sequence of implications there are
implicit parentheses grouped to the right.
So the expression above means
&#8220;if <code class="docutils literal notranslate"><span class="pre">0</span> <span class="pre">&lt;</span> <span class="pre">&#949;</span></code> then if <code class="docutils literal notranslate"><span class="pre">&#949;</span> <span class="pre">&#8804;</span> <span class="pre">1</span></code> then if <code class="docutils literal notranslate"><span class="pre">abs</span> <span class="pre">x</span> <span class="pre">&lt;</span> <span class="pre">&#949;</span></code> &#8230;&#8221;
As a result, the expression says that all the
assumptions together imply the conclusion.</p>
<p>You have already seen that even though the universal quantifier
in this statement
ranges over objects and the implication arrows introduce hypotheses,
Lean treats the two in very similar ways.
In particular, if you have proved a theorem of that form,
you can apply it to objects and hypotheses in the same way:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=import%20data.real.basic%0A%0A--%20BEGIN%0Alemma%20my_lemma%20%3A%20%E2%88%80%20x%20y%20%CE%B5%20%3A%20%E2%84%9D%2C%0A%20%200%20%3C%20%CE%B5%20%E2%86%92%20%CE%B5%20%E2%89%A4%201%20%E2%86%92%20abs%20x%20%3C%20%CE%B5%20%E2%86%92%20abs%20y%20%3C%20%CE%B5%20%E2%86%92%20abs%20(x%20*%20y)%20%3C%20%CE%B5%20%3A%3D%0Asorry%0A%0Asection%0A%20%20variables%20a%20b%20%CE%B4%20%3A%20%E2%84%9D%0A%20%20variables%20(h%E2%82%80%20%3A%200%20%3C%20%CE%B4)%20(h%E2%82%81%20%3A%20%CE%B4%20%E2%89%A4%201)%0A%20%20variables%20(ha%20%3A%20abs%20a%20%3C%20%CE%B4)%20(hb%20%3A%20abs%20b%20%3C%20%CE%B4)%0A%0A%20%20%23check%20my_lemma%20a%20b%20%CE%B4%0A%20%20%23check%20my_lemma%20a%20b%20%CE%B4%20h%E2%82%80%20h%E2%82%81%0A%20%20%23check%20my_lemma%20a%20b%20%CE%B4%20h%E2%82%80%20h%E2%82%81%20ha%20hb%0Aend%0A--%20END" target="_blank" tryitfile="../examples/logic/unnamed_51.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span class="kd">lemma</span> <span class="n">my_lemma</span> <span class="o">:</span> <span class="bp">&#8704;</span> <span class="n">x</span> <span class="n">y</span> <span class="n">&#949;</span> <span class="o">:</span> <span class="n">&#8477;</span><span class="o">,</span>
  <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">&#949;</span> <span class="bp">&#8594;</span> <span class="n">&#949;</span> <span class="bp">&#8804;</span> <span class="mi">1</span> <span class="bp">&#8594;</span> <span class="n">abs</span> <span class="n">x</span> <span class="bp">&lt;</span> <span class="n">&#949;</span> <span class="bp">&#8594;</span> <span class="n">abs</span> <span class="n">y</span> <span class="bp">&lt;</span> <span class="n">&#949;</span> <span class="bp">&#8594;</span> <span class="n">abs</span> <span class="o">(</span><span class="n">x</span> <span class="bp">*</span> <span class="n">y</span><span class="o">)</span> <span class="bp">&lt;</span> <span class="n">&#949;</span> <span class="o">:=</span>
<span class="n">sorry</span>

<span class="kn">section</span>
  <span class="kd">variables</span> <span class="n">a</span> <span class="n">b</span> <span class="n">&#948;</span> <span class="o">:</span> <span class="n">&#8477;</span>
  <span class="kd">variables</span> <span class="o">(</span><span class="n">h&#8320;</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">&#948;</span><span class="o">)</span> <span class="o">(</span><span class="n">h&#8321;</span> <span class="o">:</span> <span class="n">&#948;</span> <span class="bp">&#8804;</span> <span class="mi">1</span><span class="o">)</span>
  <span class="kd">variables</span> <span class="o">(</span><span class="n">ha</span> <span class="o">:</span> <span class="n">abs</span> <span class="n">a</span> <span class="bp">&lt;</span> <span class="n">&#948;</span><span class="o">)</span> <span class="o">(</span><span class="n">hb</span> <span class="o">:</span> <span class="n">abs</span> <span class="n">b</span> <span class="bp">&lt;</span> <span class="n">&#948;</span><span class="o">)</span>

  <span class="k">#check</span> <span class="n">my_lemma</span> <span class="n">a</span> <span class="n">b</span> <span class="n">&#948;</span>
  <span class="k">#check</span> <span class="n">my_lemma</span> <span class="n">a</span> <span class="n">b</span> <span class="n">&#948;</span> <span class="n">h&#8320;</span> <span class="n">h&#8321;</span>
  <span class="k">#check</span> <span class="n">my_lemma</span> <span class="n">a</span> <span class="n">b</span> <span class="n">&#948;</span> <span class="n">h&#8320;</span> <span class="n">h&#8321;</span> <span class="n">ha</span> <span class="n">hb</span>
<span class="kd">end</span>
</pre></div>
</div>
</div><p>You have also already seen that it is common in Lean
to use curly brackets to make quantified variables implicit
when they can be inferred from subsequent hypotheses.
When we do that, we can just apply a lemma to the hypotheses without
mentioning the objects.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=import%20data.real.basic%0A%0A--%20BEGIN%0Alemma%20my_lemma%20%3A%20%E2%88%80%20%7Bx%20y%20%CE%B5%20%3A%20%E2%84%9D%7D%2C%0A%20%200%20%3C%20%CE%B5%20%E2%86%92%20%CE%B5%20%E2%89%A4%201%20%E2%86%92%20abs%20x%20%3C%20%CE%B5%20%E2%86%92%20abs%20y%20%3C%20%CE%B5%20%E2%86%92%20abs%20(x%20*%20y)%20%3C%20%CE%B5%20%3A%3D%0Asorry%0A%0Asection%0A%20%20variables%20a%20b%20%CE%B4%20%3A%20%E2%84%9D%0A%20%20variables%20(h%E2%82%80%20%3A%200%20%3C%20%CE%B4)%20(h%E2%82%81%20%3A%20%CE%B4%20%E2%89%A4%201)%0A%20%20variables%20(ha%20%3A%20abs%20a%20%3C%20%CE%B4)%20(hb%20%3A%20abs%20b%20%3C%20%CE%B4)%0A%0A%20%20%23check%20my_lemma%20h%E2%82%80%20h%E2%82%81%20ha%20hb%0Aend%0A--%20END" target="_blank" tryitfile="../examples/logic/unnamed_77.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span class="kd">lemma</span> <span class="n">my_lemma</span> <span class="o">:</span> <span class="bp">&#8704;</span> <span class="o">{</span><span class="n">x</span> <span class="n">y</span> <span class="n">&#949;</span> <span class="o">:</span> <span class="n">&#8477;</span><span class="o">},</span>
  <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">&#949;</span> <span class="bp">&#8594;</span> <span class="n">&#949;</span> <span class="bp">&#8804;</span> <span class="mi">1</span> <span class="bp">&#8594;</span> <span class="n">abs</span> <span class="n">x</span> <span class="bp">&lt;</span> <span class="n">&#949;</span> <span class="bp">&#8594;</span> <span class="n">abs</span> <span class="n">y</span> <span class="bp">&lt;</span> <span class="n">&#949;</span> <span class="bp">&#8594;</span> <span class="n">abs</span> <span class="o">(</span><span class="n">x</span> <span class="bp">*</span> <span class="n">y</span><span class="o">)</span> <span class="bp">&lt;</span> <span class="n">&#949;</span> <span class="o">:=</span>
<span class="n">sorry</span>

<span class="kn">section</span>
  <span class="kd">variables</span> <span class="n">a</span> <span class="n">b</span> <span class="n">&#948;</span> <span class="o">:</span> <span class="n">&#8477;</span>
  <span class="kd">variables</span> <span class="o">(</span><span class="n">h&#8320;</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">&#948;</span><span class="o">)</span> <span class="o">(</span><span class="n">h&#8321;</span> <span class="o">:</span> <span class="n">&#948;</span> <span class="bp">&#8804;</span> <span class="mi">1</span><span class="o">)</span>
  <span class="kd">variables</span> <span class="o">(</span><span class="n">ha</span> <span class="o">:</span> <span class="n">abs</span> <span class="n">a</span> <span class="bp">&lt;</span> <span class="n">&#948;</span><span class="o">)</span> <span class="o">(</span><span class="n">hb</span> <span class="o">:</span> <span class="n">abs</span> <span class="n">b</span> <span class="bp">&lt;</span> <span class="n">&#948;</span><span class="o">)</span>

  <span class="k">#check</span> <span class="n">my_lemma</span> <span class="n">h&#8320;</span> <span class="n">h&#8321;</span> <span class="n">ha</span> <span class="n">hb</span>
<span class="kd">end</span>
</pre></div>
</div>
</div><p>At this stage, you also know that if you use
the <code class="docutils literal notranslate"><span class="pre">apply</span></code> tactic to apply <code class="docutils literal notranslate"><span class="pre">my_lemma</span></code>
to a goal of the form <code class="docutils literal notranslate"><span class="pre">abs</span> <span class="pre">(a</span> <span class="pre">*</span> <span class="pre">b)</span> <span class="pre">&lt;</span> <span class="pre">&#948;</span></code>,
you are left with new goals that require you to  prove
each of the hypotheses.</p>
<p>To prove a statement like this, use the <code class="docutils literal notranslate"><span class="pre">intros</span></code> tactic.
Take a look at what it does in this example:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=import%20data.real.basic%0A%0A--%20BEGIN%0Alemma%20my_lemma%20%3A%20%E2%88%80%20%7Bx%20y%20%CE%B5%20%3A%20%E2%84%9D%7D%2C%0A%20%200%20%3C%20%CE%B5%20%E2%86%92%20%CE%B5%20%E2%89%A4%201%20%E2%86%92%20abs%20x%20%3C%20%CE%B5%20%E2%86%92%20abs%20y%20%3C%20%CE%B5%20%E2%86%92%20abs%20(x%20*%20y)%20%3C%20%CE%B5%20%3A%3D%0Abegin%0A%20%20intros%20x%20y%20%CE%B5%20epos%20ele1%20xlt%20ylt%2C%0A%20%20sorry%0Aend%0A--%20END" target="_blank" tryitfile="../examples/logic/unnamed_104.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span class="kd">lemma</span> <span class="n">my_lemma</span> <span class="o">:</span> <span class="bp">&#8704;</span> <span class="o">{</span><span class="n">x</span> <span class="n">y</span> <span class="n">&#949;</span> <span class="o">:</span> <span class="n">&#8477;</span><span class="o">},</span>
  <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">&#949;</span> <span class="bp">&#8594;</span> <span class="n">&#949;</span> <span class="bp">&#8804;</span> <span class="mi">1</span> <span class="bp">&#8594;</span> <span class="n">abs</span> <span class="n">x</span> <span class="bp">&lt;</span> <span class="n">&#949;</span> <span class="bp">&#8594;</span> <span class="n">abs</span> <span class="n">y</span> <span class="bp">&lt;</span> <span class="n">&#949;</span> <span class="bp">&#8594;</span> <span class="n">abs</span> <span class="o">(</span><span class="n">x</span> <span class="bp">*</span> <span class="n">y</span><span class="o">)</span> <span class="bp">&lt;</span> <span class="n">&#949;</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">intros</span> <span class="n">x</span> <span class="n">y</span> <span class="n">&#949;</span> <span class="n">epos</span> <span class="n">ele1</span> <span class="n">xlt</span> <span class="n">ylt</span><span class="o">,</span>
  <span class="n">sorry</span>
<span class="kd">end</span>
</pre></div>
</div>
</div><p>We can use any names we want for the universally quantified variables;
they do not have to be <code class="docutils literal notranslate"><span class="pre">x</span></code>, <code class="docutils literal notranslate"><span class="pre">y</span></code>, and <code class="docutils literal notranslate"><span class="pre">&#949;</span></code>.
Notice that we have to introduce the variables
even though they are marked implicit:
making them implicit means that we leave them out when
we write an expression,
but they are still an essential part of the statement
that we are proving.
After the <code class="docutils literal notranslate"><span class="pre">intros</span></code> command,
the goal is what it would have been at the start if we
listed all the variables and hypotheses <em>before</em> the colon,
as we did in the last section.
In a moment, we will see why it is sometimes necessary to
introduce variables and hypotheses after the proof begins.</p>
<p>To help you prove the lemma, we will start you off:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=import%20data.real.basic%0A%0A--%20BEGIN%0Alemma%20my_lemma%20%3A%20%E2%88%80%20%7Bx%20y%20%CE%B5%20%3A%20%E2%84%9D%7D%2C%0A%20%200%20%3C%20%CE%B5%20%E2%86%92%20%CE%B5%20%E2%89%A4%201%20%E2%86%92%20abs%20x%20%3C%20%CE%B5%20%E2%86%92%20abs%20y%20%3C%20%CE%B5%20%E2%86%92%20abs%20(x%20*%20y)%20%3C%20%CE%B5%20%3A%3D%0Abegin%0A%20%20intros%20x%20y%20%CE%B5%20epos%20ele1%20xlt%20ylt%2C%0A%20%20calc%0A%20%20%20%20abs%20(x%20*%20y)%20%3D%20abs%20x%20*%20abs%20y%20%3A%20sorry%0A%20%20%20%20...%20%E2%89%A4%20abs%20x%20*%20%CE%B5%20%20%20%20%20%20%20%20%20%20%20%20%20%3A%20sorry%0A%20%20%20%20...%20%3C%201%20*%20%CE%B5%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%3A%20sorry%0A%20%20%20%20...%20%3D%20%CE%B5%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%3A%20sorry%0Aend%0A--%20END" target="_blank" tryitfile="../examples/logic/unnamed_134.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span class="kd">lemma</span> <span class="n">my_lemma</span> <span class="o">:</span> <span class="bp">&#8704;</span> <span class="o">{</span><span class="n">x</span> <span class="n">y</span> <span class="n">&#949;</span> <span class="o">:</span> <span class="n">&#8477;</span><span class="o">},</span>
  <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">&#949;</span> <span class="bp">&#8594;</span> <span class="n">&#949;</span> <span class="bp">&#8804;</span> <span class="mi">1</span> <span class="bp">&#8594;</span> <span class="n">abs</span> <span class="n">x</span> <span class="bp">&lt;</span> <span class="n">&#949;</span> <span class="bp">&#8594;</span> <span class="n">abs</span> <span class="n">y</span> <span class="bp">&lt;</span> <span class="n">&#949;</span> <span class="bp">&#8594;</span> <span class="n">abs</span> <span class="o">(</span><span class="n">x</span> <span class="bp">*</span> <span class="n">y</span><span class="o">)</span> <span class="bp">&lt;</span> <span class="n">&#949;</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">intros</span> <span class="n">x</span> <span class="n">y</span> <span class="n">&#949;</span> <span class="n">epos</span> <span class="n">ele1</span> <span class="n">xlt</span> <span class="n">ylt</span><span class="o">,</span>
  <span class="k">calc</span>
    <span class="n">abs</span> <span class="o">(</span><span class="n">x</span> <span class="bp">*</span> <span class="n">y</span><span class="o">)</span> <span class="bp">=</span> <span class="n">abs</span> <span class="n">x</span> <span class="bp">*</span> <span class="n">abs</span> <span class="n">y</span> <span class="o">:</span> <span class="n">sorry</span>
    <span class="bp">...</span> <span class="bp">&#8804;</span> <span class="n">abs</span> <span class="n">x</span> <span class="bp">*</span> <span class="n">&#949;</span>             <span class="o">:</span> <span class="n">sorry</span>
    <span class="bp">...</span> <span class="bp">&lt;</span> <span class="mi">1</span> <span class="bp">*</span> <span class="n">&#949;</span>                 <span class="o">:</span> <span class="n">sorry</span>
    <span class="bp">...</span> <span class="bp">=</span> <span class="n">&#949;</span>                     <span class="o">:</span> <span class="n">sorry</span>
<span class="kd">end</span>
</pre></div>
</div>
</div><p>Finish the proof using the theorems
<code class="docutils literal notranslate"><span class="pre">abs_mul</span></code>, <code class="docutils literal notranslate"><span class="pre">mul_le_mul</span></code>, <code class="docutils literal notranslate"><span class="pre">abs_nonneg</span></code>,
<code class="docutils literal notranslate"><span class="pre">mul_lt_mul_right</span></code>, and <code class="docutils literal notranslate"><span class="pre">one_mul</span></code>.
Remember that you can find theorems like these using
tab completion.
Remember also that you can use <code class="docutils literal notranslate"><span class="pre">.mp</span></code> and <code class="docutils literal notranslate"><span class="pre">.mpr</span></code>
or <code class="docutils literal notranslate"><span class="pre">.1</span></code> and <code class="docutils literal notranslate"><span class="pre">.2</span></code> to extract the two directions
of an if-and-only-if statement.</p>
<p>Universal quantifiers are often hidden in definitions,
and Lean will unfold definitions to expose them when necessary.
For example, let&#8217;s define two predicates,
<code class="docutils literal notranslate"><span class="pre">fn_ub</span> <span class="pre">f</span> <span class="pre">a</span></code> and <code class="docutils literal notranslate"><span class="pre">fn_lb</span> <span class="pre">f</span> <span class="pre">a</span></code>,
where <code class="docutils literal notranslate"><span class="pre">f</span></code> is a function from the real numbers to the real
numbers and <code class="docutils literal notranslate"><span class="pre">a</span></code> is a real number.
The first says that <code class="docutils literal notranslate"><span class="pre">a</span></code> is an upper bound on the
values of <code class="docutils literal notranslate"><span class="pre">f</span></code>,
and the second says that <code class="docutils literal notranslate"><span class="pre">a</span></code> is a lower bound
on the values of <code class="docutils literal notranslate"><span class="pre">f</span></code>.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=import%20data.real.basic%0A%0A--%20BEGIN%0Adef%20fn_ub%20(f%20%3A%20%E2%84%9D%20%E2%86%92%20%E2%84%9D)%20(a%20%3A%20%E2%84%9D)%20%3A%20Prop%20%3A%3D%20%E2%88%80%20x%2C%20f%20x%20%E2%89%A4%20a%0Adef%20fn_lb%20(f%20%3A%20%E2%84%9D%20%E2%86%92%20%E2%84%9D)%20(a%20%3A%20%E2%84%9D)%20%3A%20Prop%20%3A%3D%20%E2%88%80%20x%2C%20a%20%E2%89%A4%20f%20x%0A--%20END" target="_blank" tryitfile="../examples/logic/unnamed_180.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span class="kd">def</span> <span class="n">fn_ub</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">&#8477;</span> <span class="bp">&#8594;</span> <span class="n">&#8477;</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">&#8477;</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="bp">&#8704;</span> <span class="n">x</span><span class="o">,</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">&#8804;</span> <span class="n">a</span>
<span class="kd">def</span> <span class="n">fn_lb</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">&#8477;</span> <span class="bp">&#8594;</span> <span class="n">&#8477;</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">&#8477;</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="bp">&#8704;</span> <span class="n">x</span><span class="o">,</span> <span class="n">a</span> <span class="bp">&#8804;</span> <span class="n">f</span> <span class="n">x</span>
</pre></div>
</div>
</div><p>In the next example, remember that <code class="docutils literal notranslate"><span class="pre">&#955;</span> <span class="pre">x,</span> <span class="pre">f</span> <span class="pre">x</span> <span class="pre">+</span> <span class="pre">g</span> <span class="pre">x</span></code> is the
function that maps <code class="docutils literal notranslate"><span class="pre">x</span></code> to <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">x</span> <span class="pre">+</span> <span class="pre">g</span> <span class="pre">x</span></code>.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=import%20data.real.basic%0A%0Adef%20fn_ub%20(f%20%3A%20%E2%84%9D%20%E2%86%92%20%E2%84%9D)%20(a%20%3A%20%E2%84%9D)%20%3A%20Prop%20%3A%3D%20%E2%88%80%20x%2C%20f%20x%20%E2%89%A4%20a%0Adef%20fn_lb%20(f%20%3A%20%E2%84%9D%20%E2%86%92%20%E2%84%9D)%20(a%20%3A%20%E2%84%9D)%20%3A%20Prop%20%3A%3D%20%E2%88%80%20x%2C%20a%20%E2%89%A4%20f%20x%0A%0Avariables%20(f%20g%20%3A%20%E2%84%9D%20%E2%86%92%20%E2%84%9D)%20(a%20b%20%3A%20%E2%84%9D)%0A%0A--%20BEGIN%0Aexample%20(hfa%20%3A%20fn_ub%20f%20a)%20(hgb%20%3A%20fn_ub%20g%20b)%20%3A%0A%20%20fn_ub%20(%CE%BB%20x%2C%20f%20x%20%2B%20g%20x)%20(a%20%2B%20b)%20%3A%3D%0Abegin%0A%20%20intro%20x%2C%0A%20%20dsimp%2C%0A%20%20apply%20add_le_add%2C%0A%20%20apply%20hfa%2C%0A%20%20apply%20hgb%0Aend%0A--%20END" target="_blank" tryitfile="../examples/logic/unnamed_192.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span class="kd">example</span> <span class="o">(</span><span class="n">hfa</span> <span class="o">:</span> <span class="n">fn_ub</span> <span class="n">f</span> <span class="n">a</span><span class="o">)</span> <span class="o">(</span><span class="n">hgb</span> <span class="o">:</span> <span class="n">fn_ub</span> <span class="n">g</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">fn_ub</span> <span class="o">(</span><span class="bp">&#955;</span> <span class="n">x</span><span class="o">,</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">+</span> <span class="n">g</span> <span class="n">x</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="bp">+</span> <span class="n">b</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">intro</span> <span class="n">x</span><span class="o">,</span>
  <span class="n">dsimp</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">add_le_add</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">hfa</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">hgb</span>
<span class="kd">end</span>
</pre></div>
</div>
</div><p>Applying <code class="docutils literal notranslate"><span class="pre">intro</span></code> to the predicate <code class="docutils literal notranslate"><span class="pre">fn_ub</span> <span class="pre">(&#955;</span> <span class="pre">x,</span> <span class="pre">f</span> <span class="pre">x</span> <span class="pre">+</span> <span class="pre">g</span> <span class="pre">x)</span> <span class="pre">(a</span> <span class="pre">+</span> <span class="pre">b)</span></code>
forces Lean to unfold the definition of <code class="docutils literal notranslate"><span class="pre">fn_ub</span></code>
and introduce <code class="docutils literal notranslate"><span class="pre">x</span></code> for the universal quantifier.
The goal is then <code class="docutils literal notranslate"><span class="pre">(&#955;</span> <span class="pre">(x</span> <span class="pre">:</span> <span class="pre">&#8477;),</span> <span class="pre">f</span> <span class="pre">x</span> <span class="pre">+</span> <span class="pre">g</span> <span class="pre">x)</span> <span class="pre">x</span> <span class="pre">&#8804;</span> <span class="pre">a</span> <span class="pre">+</span> <span class="pre">b</span></code>.
But applying <code class="docutils literal notranslate"><span class="pre">(&#955;</span> <span class="pre">x,</span> <span class="pre">f</span> <span class="pre">x</span> <span class="pre">+</span> <span class="pre">g</span> <span class="pre">x)</span></code> to <code class="docutils literal notranslate"><span class="pre">x</span></code> should result in <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">x</span> <span class="pre">+</span> <span class="pre">g</span> <span class="pre">x</span></code>,
and the <code class="docutils literal notranslate"><span class="pre">dsimp</span></code> command performs that simplification.
(The &#8220;d&#8221; stands for &#8220;definitional.&#8221;)
You can delete that command and the proof still works;
Lean would have to perform that contraction anyhow to make
sense of the next <code class="docutils literal notranslate"><span class="pre">apply</span></code>.
The <code class="docutils literal notranslate"><span class="pre">dsimp</span></code> command simply makes the goal more readable
and helps us figure out what to do next.
Another option is to use the <code class="docutils literal notranslate"><span class="pre">change</span></code> tactic
by writing <code class="docutils literal notranslate"><span class="pre">change</span> <span class="pre">f</span> <span class="pre">x</span> <span class="pre">+</span> <span class="pre">g</span> <span class="pre">x</span> <span class="pre">&#8804;</span> <span class="pre">a</span> <span class="pre">+</span> <span class="pre">b</span></code>.
This helps make the proof more readable,
and gives you more control over how the goal is transformed.</p>
<p>The rest of the proof is routine.
The last two <code class="docutils literal notranslate"><span class="pre">apply</span></code> commands force Lean to unfold the definitions
of <code class="docutils literal notranslate"><span class="pre">fn_ub</span></code> in the hypotheses.
Try carrying out similar proofs of these:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=import%20data.real.basic%0A%0Adef%20fn_ub%20(f%20%3A%20%E2%84%9D%20%E2%86%92%20%E2%84%9D)%20(a%20%3A%20%E2%84%9D)%20%3A%20Prop%20%3A%3D%20%E2%88%80%20x%2C%20f%20x%20%E2%89%A4%20a%0Adef%20fn_lb%20(f%20%3A%20%E2%84%9D%20%E2%86%92%20%E2%84%9D)%20(a%20%3A%20%E2%84%9D)%20%3A%20Prop%20%3A%3D%20%E2%88%80%20x%2C%20a%20%E2%89%A4%20f%20x%0A%0Avariables%20(f%20g%20%3A%20%E2%84%9D%20%E2%86%92%20%E2%84%9D)%20(a%20b%20%3A%20%E2%84%9D)%0A%0A--%20BEGIN%0Aexample%20(hfa%20%3A%20fn_lb%20f%20a)%20(hgb%20%3A%20fn_lb%20g%20b)%20%3A%0A%20%20fn_lb%20(%CE%BB%20x%2C%20f%20x%20%2B%20g%20x)%20(a%20%2B%20b)%20%3A%3D%0Asorry%0A%0Aexample%20(nnf%20%3A%20fn_lb%20f%200)%20(nng%20%3A%20fn_lb%20g%200)%20%3A%0A%20%20fn_lb%20(%CE%BB%20x%2C%20f%20x%20*%20g%20x)%200%20%3A%3D%0Asorry%0A%0Aexample%20(hfa%20%3A%20fn_ub%20f%20a)%20(hfb%20%3A%20fn_ub%20g%20b)%0A%20%20%20%20(nng%20%3A%20fn_lb%20g%200)%20(nna%20%3A%200%20%E2%89%A4%20a)%20%3A%0A%20%20fn_ub%20(%CE%BB%20x%2C%20f%20x%20*%20g%20x)%20(a%20*%20b)%20%3A%3D%0Asorry%0A--%20END" target="_blank" tryitfile="../examples/logic/unnamed_235.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span class="kd">example</span> <span class="o">(</span><span class="n">hfa</span> <span class="o">:</span> <span class="n">fn_lb</span> <span class="n">f</span> <span class="n">a</span><span class="o">)</span> <span class="o">(</span><span class="n">hgb</span> <span class="o">:</span> <span class="n">fn_lb</span> <span class="n">g</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">fn_lb</span> <span class="o">(</span><span class="bp">&#955;</span> <span class="n">x</span><span class="o">,</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">+</span> <span class="n">g</span> <span class="n">x</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="bp">+</span> <span class="n">b</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">sorry</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">nnf</span> <span class="o">:</span> <span class="n">fn_lb</span> <span class="n">f</span> <span class="mi">0</span><span class="o">)</span> <span class="o">(</span><span class="n">nng</span> <span class="o">:</span> <span class="n">fn_lb</span> <span class="n">g</span> <span class="mi">0</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">fn_lb</span> <span class="o">(</span><span class="bp">&#955;</span> <span class="n">x</span><span class="o">,</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">*</span> <span class="n">g</span> <span class="n">x</span><span class="o">)</span> <span class="mi">0</span> <span class="o">:=</span>
<span class="n">sorry</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">hfa</span> <span class="o">:</span> <span class="n">fn_ub</span> <span class="n">f</span> <span class="n">a</span><span class="o">)</span> <span class="o">(</span><span class="n">hfb</span> <span class="o">:</span> <span class="n">fn_ub</span> <span class="n">g</span> <span class="n">b</span><span class="o">)</span>
    <span class="o">(</span><span class="n">nng</span> <span class="o">:</span> <span class="n">fn_lb</span> <span class="n">g</span> <span class="mi">0</span><span class="o">)</span> <span class="o">(</span><span class="n">nna</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">&#8804;</span> <span class="n">a</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">fn_ub</span> <span class="o">(</span><span class="bp">&#955;</span> <span class="n">x</span><span class="o">,</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">*</span> <span class="n">g</span> <span class="n">x</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="bp">*</span> <span class="n">b</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">sorry</span>
</pre></div>
</div>
</div><p>Even though we have defined <code class="docutils literal notranslate"><span class="pre">fn_ub</span></code> and <code class="docutils literal notranslate"><span class="pre">fn_lb</span></code> for functions
from the reals to the reals,
you should recognize that the definitions and proofs are much
more general.
The definitions make sense for functions between any two types
for which there is a notion of order on the codomain.
Checking the type of the theorem <code class="docutils literal notranslate"><span class="pre">add_le_add</span></code> shows that it holds
of any structure that is an &#8220;ordered additive commutative monoid&#8221;;
the details of what that means don&#8217;t matter now,
but it is worth knowing that the natural numbers, integers, rationals,
and real numbers are all instances.
So if we prove the theorem <code class="docutils literal notranslate"><span class="pre">fn_ub_add</span></code> at that level of generality,
it will apply in all these instances.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=import%20algebra.ordered_group%0A%0Avariables%20%7B%CE%B1%20%3A%20Type*%7D%20%7BR%20%3A%20Type*%7D%20%5Bordered_cancel_add_comm_monoid%20R%5D%0A%0A%23check%20%40add_le_add%0A%0Adef%20fn_ub%20(f%20%3A%20%CE%B1%20%E2%86%92%20R)%20(a%20%3A%20R)%20%3A%20Prop%20%3A%3D%20%E2%88%80%20x%2C%20f%20x%20%E2%89%A4%20a%0A%0Atheorem%20fn_ub_add%20%7Bf%20g%20%3A%20%CE%B1%20%E2%86%92%20R%7D%20%7Ba%20b%20%3A%20R%7D%0A%20%20%20%20(hfa%20%3A%20fn_ub%20f%20a)%20(hgb%20%3A%20fn_ub%20g%20b)%20%3A%0A%20%20fn_ub%20(%CE%BB%20x%2C%20f%20x%20%2B%20g%20x)%20(a%20%2B%20b)%20%3A%3D%0A%CE%BB%20x%2C%20add_le_add%20(hfa%20x)%20(hgb%20x)" target="_blank" tryitfile="../examples/logic/unnamed_273.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span class="kn">import</span> <span class="n">algebra.ordered_group</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">&#945;</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">ordered_cancel_add_comm_monoid</span> <span class="n">R</span><span class="o">]</span>

<span class="k">#check</span> <span class="bp">@</span><span class="n">add_le_add</span>

<span class="kd">def</span> <span class="n">fn_ub</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">&#945;</span> <span class="bp">&#8594;</span> <span class="n">R</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">R</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="bp">&#8704;</span> <span class="n">x</span><span class="o">,</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">&#8804;</span> <span class="n">a</span>

<span class="kd">theorem</span> <span class="n">fn_ub_add</span> <span class="o">{</span><span class="n">f</span> <span class="n">g</span> <span class="o">:</span> <span class="n">&#945;</span> <span class="bp">&#8594;</span> <span class="n">R</span><span class="o">}</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">R</span><span class="o">}</span>
    <span class="o">(</span><span class="n">hfa</span> <span class="o">:</span> <span class="n">fn_ub</span> <span class="n">f</span> <span class="n">a</span><span class="o">)</span> <span class="o">(</span><span class="n">hgb</span> <span class="o">:</span> <span class="n">fn_ub</span> <span class="n">g</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">fn_ub</span> <span class="o">(</span><span class="bp">&#955;</span> <span class="n">x</span><span class="o">,</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">+</span> <span class="n">g</span> <span class="n">x</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="bp">+</span> <span class="n">b</span><span class="o">)</span> <span class="o">:=</span>
<span class="bp">&#955;</span> <span class="n">x</span><span class="o">,</span> <span class="n">add_le_add</span> <span class="o">(</span><span class="n">hfa</span> <span class="n">x</span><span class="o">)</span> <span class="o">(</span><span class="n">hgb</span> <span class="n">x</span><span class="o">)</span>
</pre></div>
</div>
</div><p>You have already seen square brackets like these in
Section <a class="reference internal" href="basics.html#proving-identities-in-algebraic-structures"><span class="std std-numref">Section 2.2</span></a>,
though we still haven&#8217;t explained what they mean.
For concreteness, we will stick to the real numbers
for most of our examples,
but it is worth knowing that mathlib contains definitions and theorems
that work at a high level of generality.</p>
<p>For another example of a hidden universal quantifier,
mathlib defines a predicate <code class="docutils literal notranslate"><span class="pre">monotone</span></code>,
which says that a function is nondecreasing in its arguments:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=import%20data.real.basic%0A%0A--%20BEGIN%0Aexample%20(f%20%3A%20%E2%84%9D%20%E2%86%92%20%E2%84%9D)%20(h%20%3A%20monotone%20f)%20%3A%0A%20%20%E2%88%80%20%7Ba%20b%7D%2C%20a%20%E2%89%A4%20b%20%E2%86%92%20f%20a%20%E2%89%A4%20f%20b%20%3A%3D%20h%0A--%20END" target="_blank" tryitfile="../examples/logic/unnamed_300.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span class="kd">example</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">&#8477;</span> <span class="bp">&#8594;</span> <span class="n">&#8477;</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">monotone</span> <span class="n">f</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">&#8704;</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span><span class="o">},</span> <span class="n">a</span> <span class="bp">&#8804;</span> <span class="n">b</span> <span class="bp">&#8594;</span> <span class="n">f</span> <span class="n">a</span> <span class="bp">&#8804;</span> <span class="n">f</span> <span class="n">b</span> <span class="o">:=</span> <span class="n">h</span>
</pre></div>
</div>
</div><p>Proving statements about monotonicity
involves using <code class="docutils literal notranslate"><span class="pre">intros</span></code> to introduce two variables,
say, <code class="docutils literal notranslate"><span class="pre">a</span></code> and <code class="docutils literal notranslate"><span class="pre">b</span></code>, and the hypothesis <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">&#8804;</span> <span class="pre">b</span></code>.
To <em>use</em> a monotonicity hypothesis,
you can apply it to suitable arguments and hypotheses,
and then apply the resulting expression to the goal.
Or you can apply it to the goal and let Lean help you
work backwards by displaying the remaining hypotheses
as new subgoals.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=import%20data.real.basic%0A%0Avariables%20(f%20g%20%3A%20%E2%84%9D%20%E2%86%92%20%E2%84%9D)%0A%0A--%20BEGIN%0Aexample%20(mf%20%3A%20monotone%20f)%20(mg%20%3A%20monotone%20g)%20%3A%0A%20%20monotone%20(%CE%BB%20x%2C%20f%20x%20%2B%20g%20x)%20%3A%3D%0Abegin%0A%20%20intros%20a%20b%20aleb%2C%0A%20%20apply%20add_le_add%2C%0A%20%20apply%20mf%20aleb%2C%0A%20%20apply%20mg%20aleb%0Aend%0A--%20END" target="_blank" tryitfile="../examples/logic/unnamed_319.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span class="kd">example</span> <span class="o">(</span><span class="n">mf</span> <span class="o">:</span> <span class="n">monotone</span> <span class="n">f</span><span class="o">)</span> <span class="o">(</span><span class="n">mg</span> <span class="o">:</span> <span class="n">monotone</span> <span class="n">g</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">monotone</span> <span class="o">(</span><span class="bp">&#955;</span> <span class="n">x</span><span class="o">,</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">+</span> <span class="n">g</span> <span class="n">x</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">intros</span> <span class="n">a</span> <span class="n">b</span> <span class="n">aleb</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">add_le_add</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">mf</span> <span class="n">aleb</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">mg</span> <span class="n">aleb</span>
<span class="kd">end</span>
</pre></div>
</div>
</div><p>When a proof is this short, it is often convenient
to give a proof term instead.
The <code class="docutils literal notranslate"><span class="pre">intros</span></code> command corresponds to a lambda,
and the remaining term consists of applications.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=import%20data.real.basic%0A%0Avariables%20(f%20g%20%3A%20%E2%84%9D%20%E2%86%92%20%E2%84%9D)%0A%0A--%20BEGIN%0Aexample%20(mf%20%3A%20monotone%20f)%20(mg%20%3A%20monotone%20g)%20%3A%0A%20%20monotone%20(%CE%BB%20x%2C%20f%20x%20%2B%20g%20x)%20%3A%3D%0A%CE%BB%20a%20b%20aleb%2C%20add_le_add%20(mf%20aleb)%20(mg%20aleb)%0A--%20END" target="_blank" tryitfile="../examples/logic/unnamed_341.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span class="kd">example</span> <span class="o">(</span><span class="n">mf</span> <span class="o">:</span> <span class="n">monotone</span> <span class="n">f</span><span class="o">)</span> <span class="o">(</span><span class="n">mg</span> <span class="o">:</span> <span class="n">monotone</span> <span class="n">g</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">monotone</span> <span class="o">(</span><span class="bp">&#955;</span> <span class="n">x</span><span class="o">,</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">+</span> <span class="n">g</span> <span class="n">x</span><span class="o">)</span> <span class="o">:=</span>
<span class="bp">&#955;</span> <span class="n">a</span> <span class="n">b</span> <span class="n">aleb</span><span class="o">,</span> <span class="n">add_le_add</span> <span class="o">(</span><span class="n">mf</span> <span class="n">aleb</span><span class="o">)</span> <span class="o">(</span><span class="n">mg</span> <span class="n">aleb</span><span class="o">)</span>
</pre></div>
</div>
</div><p>Here is a useful trick: if you start writing
the proof term <code class="docutils literal notranslate"><span class="pre">&#955;</span> <span class="pre">a</span> <span class="pre">b</span> <span class="pre">aleb,</span> <span class="pre">_</span></code> using
an underscore where the rest of the
expression should go,
Lean will flag an error,
indicating that it can&#8217;t guess the value of that expression.
If you check the Lean Goal window in VS Code or
hover over the squiggly error marker,
Lean will show you the goal that the remaining
expression has to solve.</p>
<p>Try proving these, with either tactics or proof terms:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=import%20data.real.basic%0A%0Avariables%20(f%20g%20%3A%20%E2%84%9D%20%E2%86%92%20%E2%84%9D)%0A%0A--%20BEGIN%0Aexample%20%7Bc%20%3A%20%E2%84%9D%7D%20(mf%20%3A%20monotone%20f)%20(nnc%20%3A%200%20%E2%89%A4%20c)%20%3A%0A%20%20monotone%20(%CE%BB%20x%2C%20c%20*%20f%20x)%20%3A%3D%0Asorry%0A%0Aexample%20(mf%20%3A%20monotone%20f)%20(mg%20%3A%20monotone%20g)%20%3A%0A%20%20monotone%20(%CE%BB%20x%2C%20f%20(g%20x))%20%3A%3D%0Asorry%0A--%20END" target="_blank" tryitfile="../examples/logic/unnamed_366.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span class="kd">example</span> <span class="o">{</span><span class="n">c</span> <span class="o">:</span> <span class="n">&#8477;</span><span class="o">}</span> <span class="o">(</span><span class="n">mf</span> <span class="o">:</span> <span class="n">monotone</span> <span class="n">f</span><span class="o">)</span> <span class="o">(</span><span class="n">nnc</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">&#8804;</span> <span class="n">c</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">monotone</span> <span class="o">(</span><span class="bp">&#955;</span> <span class="n">x</span><span class="o">,</span> <span class="n">c</span> <span class="bp">*</span> <span class="n">f</span> <span class="n">x</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">sorry</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">mf</span> <span class="o">:</span> <span class="n">monotone</span> <span class="n">f</span><span class="o">)</span> <span class="o">(</span><span class="n">mg</span> <span class="o">:</span> <span class="n">monotone</span> <span class="n">g</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">monotone</span> <span class="o">(</span><span class="bp">&#955;</span> <span class="n">x</span><span class="o">,</span> <span class="n">f</span> <span class="o">(</span><span class="n">g</span> <span class="n">x</span><span class="o">))</span> <span class="o">:=</span>
<span class="n">sorry</span>
</pre></div>
</div>
</div><p>Here are some more examples.
A function <span class="math notranslate nohighlight">\(f\)</span> from <span class="math notranslate nohighlight">\(\Bbb R\)</span> to
<span class="math notranslate nohighlight">\(\Bbb R\)</span> is said to be <em>even</em> if
<span class="math notranslate nohighlight">\(f(-x) = f(x)\)</span> for every <span class="math notranslate nohighlight">\(x\)</span>,
and <em>odd</em> if <span class="math notranslate nohighlight">\(f(-x) = -f(x)\)</span> for every <span class="math notranslate nohighlight">\(x\)</span>.
The following example defines these two notions formally
and establishes one fact about them.
You can complete the proofs of the others.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=import%20data.real.basic%0A%0Avariables%20(f%20g%20%3A%20%E2%84%9D%20%E2%86%92%20%E2%84%9D)%0A%0A--%20BEGIN%0Adef%20even%20(f%20%3A%20%E2%84%9D%20%E2%86%92%20%E2%84%9D)%20%3A%20Prop%20%3A%3D%20%E2%88%80%20x%2C%20f%20x%20%3D%20f%20(-x)%0Adef%20odd%20(f%20%3A%20%E2%84%9D%20%E2%86%92%20%E2%84%9D)%20%3A%20Prop%20%3A%3D%20%E2%88%80%20x%2C%20f%20x%20%3D%20-%20f%20(-x)%0A%0Aexample%20(ef%20%3A%20even%20f)%20(eg%20%3A%20even%20g)%20%3A%20even%20(%CE%BB%20x%2C%20f%20x%20%2B%20g%20x)%20%3A%3D%0Abegin%0A%20%20intro%20x%2C%0A%20%20calc%0A%20%20%20%20(%CE%BB%20x%2C%20f%20x%20%2B%20g%20x)%20x%20%3D%20f%20x%20%2B%20g%20x%20%20%20%20%20%20%20%3A%20rfl%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20...%20%3D%20f%20(-x)%20%2B%20g%20(-x)%20%3A%20by%20rw%20%5Bef%2C%20eg%5D%0Aend%0A%0Aexample%20(of%20%3A%20odd%20f)%20(og%20%3A%20odd%20g)%20%3A%20even%20(%CE%BB%20x%2C%20f%20x%20*%20g%20x)%20%3A%3D%0Asorry%0A%0Aexample%20(ef%20%3A%20even%20f)%20(og%20%3A%20odd%20g)%20%3A%20odd%20(%CE%BB%20x%2C%20f%20x%20*%20g%20x)%20%3A%3D%0Asorry%0A%0Aexample%20(ef%20%3A%20even%20f)%20(og%20%3A%20odd%20g)%20%3A%20even%20(%CE%BB%20x%2C%20f%20(g%20x))%20%3A%3D%0Asorry%0A--%20END" target="_blank" tryitfile="../examples/logic/unnamed_391.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span class="kd">def</span> <span class="n">even</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">&#8477;</span> <span class="bp">&#8594;</span> <span class="n">&#8477;</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="bp">&#8704;</span> <span class="n">x</span><span class="o">,</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">f</span> <span class="o">(</span><span class="bp">-</span><span class="n">x</span><span class="o">)</span>
<span class="kd">def</span> <span class="n">odd</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">&#8477;</span> <span class="bp">&#8594;</span> <span class="n">&#8477;</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="bp">&#8704;</span> <span class="n">x</span><span class="o">,</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">=</span> <span class="bp">-</span> <span class="n">f</span> <span class="o">(</span><span class="bp">-</span><span class="n">x</span><span class="o">)</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">ef</span> <span class="o">:</span> <span class="n">even</span> <span class="n">f</span><span class="o">)</span> <span class="o">(</span><span class="n">eg</span> <span class="o">:</span> <span class="n">even</span> <span class="n">g</span><span class="o">)</span> <span class="o">:</span> <span class="n">even</span> <span class="o">(</span><span class="bp">&#955;</span> <span class="n">x</span><span class="o">,</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">+</span> <span class="n">g</span> <span class="n">x</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">intro</span> <span class="n">x</span><span class="o">,</span>
  <span class="k">calc</span>
    <span class="o">(</span><span class="bp">&#955;</span> <span class="n">x</span><span class="o">,</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">+</span> <span class="n">g</span> <span class="n">x</span><span class="o">)</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">+</span> <span class="n">g</span> <span class="n">x</span>       <span class="o">:</span> <span class="n">rfl</span>
                   <span class="bp">...</span> <span class="bp">=</span> <span class="n">f</span> <span class="o">(</span><span class="bp">-</span><span class="n">x</span><span class="o">)</span> <span class="bp">+</span> <span class="n">g</span> <span class="o">(</span><span class="bp">-</span><span class="n">x</span><span class="o">)</span> <span class="o">:</span> <span class="kd">by</span> <span class="n">rw</span> <span class="o">[</span><span class="n">ef</span><span class="o">,</span> <span class="n">eg</span><span class="o">]</span>
<span class="kd">end</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">of</span> <span class="o">:</span> <span class="n">odd</span> <span class="n">f</span><span class="o">)</span> <span class="o">(</span><span class="n">og</span> <span class="o">:</span> <span class="n">odd</span> <span class="n">g</span><span class="o">)</span> <span class="o">:</span> <span class="n">even</span> <span class="o">(</span><span class="bp">&#955;</span> <span class="n">x</span><span class="o">,</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">*</span> <span class="n">g</span> <span class="n">x</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">sorry</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">ef</span> <span class="o">:</span> <span class="n">even</span> <span class="n">f</span><span class="o">)</span> <span class="o">(</span><span class="n">og</span> <span class="o">:</span> <span class="n">odd</span> <span class="n">g</span><span class="o">)</span> <span class="o">:</span> <span class="n">odd</span> <span class="o">(</span><span class="bp">&#955;</span> <span class="n">x</span><span class="o">,</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">*</span> <span class="n">g</span> <span class="n">x</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">sorry</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">ef</span> <span class="o">:</span> <span class="n">even</span> <span class="n">f</span><span class="o">)</span> <span class="o">(</span><span class="n">og</span> <span class="o">:</span> <span class="n">odd</span> <span class="n">g</span><span class="o">)</span> <span class="o">:</span> <span class="n">even</span> <span class="o">(</span><span class="bp">&#955;</span> <span class="n">x</span><span class="o">,</span> <span class="n">f</span> <span class="o">(</span><span class="n">g</span> <span class="n">x</span><span class="o">))</span> <span class="o">:=</span>
<span class="n">sorry</span>
</pre></div>
</div>
</div><p>The first proof can be shortened using <code class="docutils literal notranslate"><span class="pre">dsimp</span></code> or <code class="docutils literal notranslate"><span class="pre">change</span></code>
to get rid of the lambda.
But you can check that the subsequent <code class="docutils literal notranslate"><span class="pre">rw</span></code> won&#8217;t work
unless we get rid of the lambda explicitly,
because otherwise it cannot find the patterns <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">x</span></code> and <code class="docutils literal notranslate"><span class="pre">g</span> <span class="pre">x</span></code>
in the expression.</p>
<p>You can find implicit universal quantifiers all over the place,
once you know how to spot them.
Mathlib includes a good library for rudimentary set theory.
Lean&#8217;s logical foundation imposes the restriction that when
we talk about sets, we are always talking about sets of
elements of some type. If <code class="docutils literal notranslate"><span class="pre">x</span></code> has type <code class="docutils literal notranslate"><span class="pre">&#945;</span></code> and <code class="docutils literal notranslate"><span class="pre">s</span></code> has
type <code class="docutils literal notranslate"><span class="pre">set</span> <span class="pre">&#945;</span></code>, then <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">&#8712;</span> <span class="pre">s</span></code> is a proposition that
asserts that <code class="docutils literal notranslate"><span class="pre">x</span></code> is an element of <code class="docutils literal notranslate"><span class="pre">s</span></code>.
If <code class="docutils literal notranslate"><span class="pre">s</span></code> and <code class="docutils literal notranslate"><span class="pre">t</span></code> are of type <code class="docutils literal notranslate"><span class="pre">set</span> <span class="pre">&#945;</span></code>,
then the subset relation <code class="docutils literal notranslate"><span class="pre">s</span> <span class="pre">&#8838;</span> <span class="pre">t</span></code> is defined to mean
<code class="docutils literal notranslate"><span class="pre">&#8704;</span> <span class="pre">{x</span> <span class="pre">:</span> <span class="pre">&#945;},</span> <span class="pre">x</span> <span class="pre">&#8712;</span> <span class="pre">s</span> <span class="pre">&#8594;</span> <span class="pre">x</span> <span class="pre">&#8712;</span> <span class="pre">t</span></code>.
The variable in the quantifier is marked implicit so that
given <code class="docutils literal notranslate"><span class="pre">h</span> <span class="pre">:</span> <span class="pre">s</span> <span class="pre">&#8838;</span> <span class="pre">t</span></code> and <code class="docutils literal notranslate"><span class="pre">h'</span> <span class="pre">:</span> <span class="pre">x</span> <span class="pre">&#8712;</span> <span class="pre">s</span></code>,
we can write <code class="docutils literal notranslate"><span class="pre">h</span> <span class="pre">h'</span></code> as justification for <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">&#8712;</span> <span class="pre">t</span></code>.
The following example provides a tactic proof and a proof term
justifying the reflexivity of the subset relation,
and asks you to do the same for transitivity.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=variables%20%7B%CE%B1%20%3A%20Type*%7D%20(r%20s%20t%20%3A%20set%20%CE%B1)%0A%0Aexample%20%3A%20s%20%E2%8A%86%20s%20%3A%3D%0Aby%20%7B%20intros%20x%20xs%2C%20exact%20xs%20%7D%0A%0Aexample%20%3A%20s%20%E2%8A%86%20s%20%3A%3D%20%CE%BB%20x%20xs%2C%20xs%0A%0Aexample%20%3A%20r%20%E2%8A%86%20s%20%E2%86%92%20s%20%E2%8A%86%20t%20%E2%86%92%20r%20%E2%8A%86%20t%20%3A%3D%0Abegin%0A%20%20sorry%0Aend%0A%0Aexample%20%3A%20r%20%E2%8A%86%20s%20%E2%86%92%20s%20%E2%8A%86%20t%20%E2%86%92%20r%20%E2%8A%86%20t%20%3A%3D%0Asorry" target="_blank" tryitfile="../examples/logic/unnamed_444.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span class="kd">variables</span> <span class="o">{</span><span class="n">&#945;</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">r</span> <span class="n">s</span> <span class="n">t</span> <span class="o">:</span> <span class="n">set</span> <span class="n">&#945;</span><span class="o">)</span>

<span class="kd">example</span> <span class="o">:</span> <span class="n">s</span> <span class="bp">&#8838;</span> <span class="n">s</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="o">{</span> <span class="n">intros</span> <span class="n">x</span> <span class="n">xs</span><span class="o">,</span> <span class="n">exact</span> <span class="n">xs</span> <span class="o">}</span>

<span class="kd">example</span> <span class="o">:</span> <span class="n">s</span> <span class="bp">&#8838;</span> <span class="n">s</span> <span class="o">:=</span> <span class="bp">&#955;</span> <span class="n">x</span> <span class="n">xs</span><span class="o">,</span> <span class="n">xs</span>

<span class="kd">example</span> <span class="o">:</span> <span class="n">r</span> <span class="bp">&#8838;</span> <span class="n">s</span> <span class="bp">&#8594;</span> <span class="n">s</span> <span class="bp">&#8838;</span> <span class="n">t</span> <span class="bp">&#8594;</span> <span class="n">r</span> <span class="bp">&#8838;</span> <span class="n">t</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">sorry</span>
<span class="kd">end</span>

<span class="kd">example</span> <span class="o">:</span> <span class="n">r</span> <span class="bp">&#8838;</span> <span class="n">s</span> <span class="bp">&#8594;</span> <span class="n">s</span> <span class="bp">&#8838;</span> <span class="n">t</span> <span class="bp">&#8594;</span> <span class="n">r</span> <span class="bp">&#8838;</span> <span class="n">t</span> <span class="o">:=</span>
<span class="n">sorry</span>
</pre></div>
</div>
</div><p>Just as we defined <code class="docutils literal notranslate"><span class="pre">fn_ub</span></code> for functions,
we can define <code class="docutils literal notranslate"><span class="pre">set_ub</span> <span class="pre">s</span> <span class="pre">a</span></code> to mean that <code class="docutils literal notranslate"><span class="pre">a</span></code>
is an upper bound on the set <code class="docutils literal notranslate"><span class="pre">s</span></code>,
assuming <code class="docutils literal notranslate"><span class="pre">s</span></code> is a set of elements of some type that
has an order associated with it.
In the next example, we ask you to prove that
if <code class="docutils literal notranslate"><span class="pre">a</span></code> is a bound on <code class="docutils literal notranslate"><span class="pre">s</span></code> and <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">&#8804;</span> <span class="pre">b</span></code>,
then <code class="docutils literal notranslate"><span class="pre">b</span></code> is a bound on <code class="docutils literal notranslate"><span class="pre">s</span></code> as well.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=variables%20%7B%CE%B1%20%3A%20Type*%7D%20%5Bpartial_order%20%CE%B1%5D%0Avariables%20(s%20%3A%20set%20%CE%B1)%20(a%20b%20%3A%20%CE%B1)%0A%0Adef%20set_ub%20(s%20%3A%20set%20%CE%B1)%20(a%20%3A%20%CE%B1)%20%3A%3D%20%E2%88%80%20x%2C%20x%20%E2%88%88%20s%20%E2%86%92%20x%20%E2%89%A4%20a%0A%0Aexample%20(h%20%3A%20set_ub%20s%20a)%20(h'%20%3A%20a%20%E2%89%A4%20b)%20%3A%20set_ub%20s%20b%20%3A%3D%0Asorry" target="_blank" tryitfile="../examples/logic/unnamed_470.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span class="kd">variables</span> <span class="o">{</span><span class="n">&#945;</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">partial_order</span> <span class="n">&#945;</span><span class="o">]</span>
<span class="kd">variables</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">&#945;</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">&#945;</span><span class="o">)</span>

<span class="kd">def</span> <span class="n">set_ub</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">&#945;</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">&#945;</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">&#8704;</span> <span class="n">x</span><span class="o">,</span> <span class="n">x</span> <span class="bp">&#8712;</span> <span class="n">s</span> <span class="bp">&#8594;</span> <span class="n">x</span> <span class="bp">&#8804;</span> <span class="n">a</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">set_ub</span> <span class="n">s</span> <span class="n">a</span><span class="o">)</span> <span class="o">(</span><span class="n">h&#39;</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">&#8804;</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span> <span class="n">set_ub</span> <span class="n">s</span> <span class="n">b</span> <span class="o">:=</span>
<span class="n">sorry</span>
</pre></div>
</div>
</div><p>We close this section with one last important example.
A function <span class="math notranslate nohighlight">\(f\)</span> is said to be <em>injective</em> if for
every <span class="math notranslate nohighlight">\(x_1\)</span> and <span class="math notranslate nohighlight">\(x_2\)</span>,
if <span class="math notranslate nohighlight">\(f(x_1) = f(x_2)\)</span> then <span class="math notranslate nohighlight">\(x_1 = x_2\)</span>.
Mathlib defines <code class="docutils literal notranslate"><span class="pre">function.injective</span> <span class="pre">f</span></code> with
<code class="docutils literal notranslate"><span class="pre">x&#8321;</span></code> and <code class="docutils literal notranslate"><span class="pre">x&#8322;</span></code> implicit.
The next example shows that, on the real numbers,
any function that adds a constant is injective.
We then ask you to show that multiplication by a nonzero
constant is also injective.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=import%20data.real.basic%0A%0A--%20BEGIN%0Aopen%20function%0A%0Aexample%20(c%20%3A%20%E2%84%9D)%20%3A%20injective%20(%CE%BB%20x%2C%20x%20%2B%20c)%20%3A%3D%0Abegin%0A%20%20intros%20x%E2%82%81%20x%E2%82%82%20h'%2C%0A%20%20exact%20(add_left_inj%20c).mp%20h'%2C%0Aend%0A%0Aexample%20%7Bc%20%3A%20%E2%84%9D%7D%20(h%20%3A%20c%20%E2%89%A0%200)%20%3A%20injective%20(%CE%BB%20x%2C%20c%20*%20x)%20%3A%3D%0Asorry%0A--%20END" target="_blank" tryitfile="../examples/logic/unnamed_491.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span class="kn">open</span> <span class="n">function</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">c</span> <span class="o">:</span> <span class="n">&#8477;</span><span class="o">)</span> <span class="o">:</span> <span class="n">injective</span> <span class="o">(</span><span class="bp">&#955;</span> <span class="n">x</span><span class="o">,</span> <span class="n">x</span> <span class="bp">+</span> <span class="n">c</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">intros</span> <span class="n">x&#8321;</span> <span class="n">x&#8322;</span> <span class="n">h&#39;</span><span class="o">,</span>
  <span class="n">exact</span> <span class="o">(</span><span class="n">add_left_inj</span> <span class="n">c</span><span class="o">)</span><span class="bp">.</span><span class="n">mp</span> <span class="n">h&#39;</span><span class="o">,</span>
<span class="kd">end</span>

<span class="kd">example</span> <span class="o">{</span><span class="n">c</span> <span class="o">:</span> <span class="n">&#8477;</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">c</span> <span class="bp">&#8800;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">:</span> <span class="n">injective</span> <span class="o">(</span><span class="bp">&#955;</span> <span class="n">x</span><span class="o">,</span> <span class="n">c</span> <span class="bp">*</span> <span class="n">x</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">sorry</span>
</pre></div>
</div>
</div><p>Finally, show that the composition of two injective functions is injective:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=open%20function%0A%0A--%20BEGIN%0Avariables%20%7B%CE%B1%20%3A%20Type*%7D%20%7B%CE%B2%20%3A%20Type*%7D%20%7B%CE%B3%20%3A%20Type*%7D%0Avariables%20%7Bg%20%3A%20%CE%B2%20%E2%86%92%20%CE%B3%7D%20%7Bf%20%3A%20%CE%B1%20%E2%86%92%20%CE%B2%7D%0A%0Aexample%20(injg%20%3A%20injective%20g)%20(injf%20%3A%20injective%20f)%20%3A%0A%20%20injective%20(%CE%BB%20x%2C%20g%20(f%20x))%20%3A%3D%0Abegin%0A%20%20intros%20x%E2%82%81%20x%E2%82%82%20h%2C%0A%20%20apply%20injf%2C%0A%20%20apply%20injg%2C%0A%20%20apply%20h%0Aend%0A--%20END" target="_blank" tryitfile="../examples/logic/unnamed_510.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span class="kd">variables</span> <span class="o">{</span><span class="n">&#945;</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">&#946;</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">&#947;</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span>
<span class="kd">variables</span> <span class="o">{</span><span class="n">g</span> <span class="o">:</span> <span class="n">&#946;</span> <span class="bp">&#8594;</span> <span class="n">&#947;</span><span class="o">}</span> <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">&#945;</span> <span class="bp">&#8594;</span> <span class="n">&#946;</span><span class="o">}</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">injg</span> <span class="o">:</span> <span class="n">injective</span> <span class="n">g</span><span class="o">)</span> <span class="o">(</span><span class="n">injf</span> <span class="o">:</span> <span class="n">injective</span> <span class="n">f</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">injective</span> <span class="o">(</span><span class="bp">&#955;</span> <span class="n">x</span><span class="o">,</span> <span class="n">g</span> <span class="o">(</span><span class="n">f</span> <span class="n">x</span><span class="o">))</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">intros</span> <span class="n">x&#8321;</span> <span class="n">x&#8322;</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">injf</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">injg</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">h</span>
<span class="kd">end</span>
</pre></div>
</div>
</div></div>
<div class="section" id="the-existential-quantifier">
<span id="id3"></span><h2><span class="section-number">3.2. </span>The Existential Quantifier<a class="headerlink" href="#the-existential-quantifier" title="Permalink to this headline">&#182;</a></h2>
<p>The existential quantifier, which can be entered as <code class="docutils literal notranslate"><span class="pre">\ex</span></code> in VS Code,
is used to represent the phrase &#8220;there exists.&#8221;
The formal expression <code class="docutils literal notranslate"><span class="pre">&#8707;</span> <span class="pre">x</span> <span class="pre">:</span> <span class="pre">&#8477;,</span> <span class="pre">2</span> <span class="pre">&lt;</span> <span class="pre">x</span> <span class="pre">&#8743;</span> <span class="pre">x</span> <span class="pre">&lt;</span> <span class="pre">3</span></code> in Lean says
that there is a real number between 2 and 3.
(We will discuss the conjunction symbol, <code class="docutils literal notranslate"><span class="pre">&#8743;</span></code>, below.)
The canonical way to prove such a statement is to exhibit a real number
and show that it has the stated property.
The number 2.5, which we can enter as <code class="docutils literal notranslate"><span class="pre">5</span> <span class="pre">/</span> <span class="pre">2</span></code>
or <code class="docutils literal notranslate"><span class="pre">(5</span> <span class="pre">:</span> <span class="pre">&#8477;)</span> <span class="pre">/</span> <span class="pre">2</span></code> when Lean cannot infer from context that we have
the real numbers in mind, has the required property,
and the <code class="docutils literal notranslate"><span class="pre">norm_num</span></code> tactic can prove that it meets the description.</p>
<p>There are a few ways we can put the information together.
Given a goal that begins with an existential quantifier,
the <code class="docutils literal notranslate"><span class="pre">use</span></code> tactic is used to provide the object,
leaving the goal of proving the property.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=import%20data.real.basic%0A%0Aexample%20%3A%20%E2%88%83%20x%20%3A%20%E2%84%9D%2C%202%20%3C%20x%20%E2%88%A7%20x%20%3C%203%20%3A%3D%0Abegin%0A%20%20use%205%20%2F%202%2C%0A%20%20norm_num%0Aend" target="_blank" tryitfile="../examples/logic/unnamed_553.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span class="kn">import</span> <span class="n">data.real.basic</span>

<span class="kd">example</span> <span class="o">:</span> <span class="bp">&#8707;</span> <span class="n">x</span> <span class="o">:</span> <span class="n">&#8477;</span><span class="o">,</span> <span class="mi">2</span> <span class="bp">&lt;</span> <span class="n">x</span> <span class="bp">&#8743;</span> <span class="n">x</span> <span class="bp">&lt;</span> <span class="mi">3</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">use</span> <span class="mi">5</span> <span class="bp">/</span> <span class="mi">2</span><span class="o">,</span>
  <span class="n">norm_num</span>
<span class="kd">end</span>
</pre></div>
</div>
</div><p>Alternatively, we can use Lean&#8217;s <em>anonyomous constructor</em> notation
to construct the proof.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=import%20data.real.basic%0A%0A--%20BEGIN%0Aexample%20%3A%20%E2%88%83%20x%20%3A%20%E2%84%9D%2C%202%20%3C%20x%20%E2%88%A7%20x%20%3C%203%20%3A%3D%0Abegin%0A%20%20have%20h%20%3A%202%20%3C%20(5%20%3A%20%E2%84%9D)%20%2F%202%20%E2%88%A7%20(5%20%3A%20%E2%84%9D)%20%2F%202%20%3C%203%2C%0A%20%20%20%20by%20norm_num%2C%0A%20%20exact%20%E2%9F%A85%20%2F%202%2C%20h%E2%9F%A9%0Aend%0A--%20END" target="_blank" tryitfile="../examples/logic/unnamed_566.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span class="kd">example</span> <span class="o">:</span> <span class="bp">&#8707;</span> <span class="n">x</span> <span class="o">:</span> <span class="n">&#8477;</span><span class="o">,</span> <span class="mi">2</span> <span class="bp">&lt;</span> <span class="n">x</span> <span class="bp">&#8743;</span> <span class="n">x</span> <span class="bp">&lt;</span> <span class="mi">3</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="k">have</span> <span class="n">h</span> <span class="o">:</span> <span class="mi">2</span> <span class="bp">&lt;</span> <span class="o">(</span><span class="mi">5</span> <span class="o">:</span> <span class="n">&#8477;</span><span class="o">)</span> <span class="bp">/</span> <span class="mi">2</span> <span class="bp">&#8743;</span> <span class="o">(</span><span class="mi">5</span> <span class="o">:</span> <span class="n">&#8477;</span><span class="o">)</span> <span class="bp">/</span> <span class="mi">2</span> <span class="bp">&lt;</span> <span class="mi">3</span><span class="o">,</span>
    <span class="kd">by</span> <span class="n">norm_num</span><span class="o">,</span>
  <span class="n">exact</span> <span class="o">&#10216;</span><span class="mi">5</span> <span class="bp">/</span> <span class="mi">2</span><span class="o">,</span> <span class="n">h</span><span class="o">&#10217;</span>
<span class="kd">end</span>
</pre></div>
</div>
</div><p>The left and right angle brackets,
which can be entered as <code class="docutils literal notranslate"><span class="pre">\&lt;</span></code> and <code class="docutils literal notranslate"><span class="pre">\&gt;</span></code> respectively,
tell Lean to put together the given data using
whatever construction is appropriate
for the current goal.
We can use the notation without going into tactic mode:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=import%20data.real.basic%0A%0A--%20BEGIN%0Aexample%20%3A%20%E2%88%83%20x%20%3A%20%E2%84%9D%2C%202%20%3C%20x%20%E2%88%A7%20x%20%3C%203%20%3A%3D%0A%E2%9F%A85%20%2F%202%2C%20by%20norm_num%E2%9F%A9%0A--%20END" target="_blank" tryitfile="../examples/logic/unnamed_586.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span class="kd">example</span> <span class="o">:</span> <span class="bp">&#8707;</span> <span class="n">x</span> <span class="o">:</span> <span class="n">&#8477;</span><span class="o">,</span> <span class="mi">2</span> <span class="bp">&lt;</span> <span class="n">x</span> <span class="bp">&#8743;</span> <span class="n">x</span> <span class="bp">&lt;</span> <span class="mi">3</span> <span class="o">:=</span>
<span class="o">&#10216;</span><span class="mi">5</span> <span class="bp">/</span> <span class="mi">2</span><span class="o">,</span> <span class="kd">by</span> <span class="n">norm_num</span><span class="o">&#10217;</span>
</pre></div>
</div>
</div><p>So now we know how to <em>prove</em> an exists statement.
But how do we <em>use</em> one?
If we know that there exists an object with a certain property,
we should be able to give a name to an arbitrary one
and reason about it.
For example, remember the predicates <code class="docutils literal notranslate"><span class="pre">fn_ub</span> <span class="pre">f</span> <span class="pre">a</span></code> and <code class="docutils literal notranslate"><span class="pre">fn_lb</span> <span class="pre">f</span> <span class="pre">a</span></code>
from the last section,
which say that <code class="docutils literal notranslate"><span class="pre">a</span></code> is an upper bound or lower bound on <code class="docutils literal notranslate"><span class="pre">f</span></code>,
respectively.
We can use the existential quantifier to say that &#8220;<code class="docutils literal notranslate"><span class="pre">f</span></code> is bounded&#8221;
without specifying the bound:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=import%20data.real.basic%0A%0A--%20BEGIN%0Adef%20fn_ub%20(f%20%3A%20%E2%84%9D%20%E2%86%92%20%E2%84%9D)%20(a%20%3A%20%E2%84%9D)%20%3A%20Prop%20%3A%3D%20%E2%88%80%20x%2C%20f%20x%20%E2%89%A4%20a%0Adef%20fn_lb%20(f%20%3A%20%E2%84%9D%20%E2%86%92%20%E2%84%9D)%20(a%20%3A%20%E2%84%9D)%20%3A%20Prop%20%3A%3D%20%E2%88%80%20x%2C%20a%20%E2%89%A4%20f%20x%0A%0Adef%20fn_has_ub%20(f%20%3A%20%E2%84%9D%20%E2%86%92%20%E2%84%9D)%20%3A%3D%20%E2%88%83%20a%2C%20fn_ub%20f%20a%0Adef%20fn_has_lb%20(f%20%3A%20%E2%84%9D%20%E2%86%92%20%E2%84%9D)%20%3A%3D%20%E2%88%83%20a%2C%20fn_lb%20f%20a%0A--%20END" target="_blank" tryitfile="../examples/logic/unnamed_607.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span class="kd">def</span> <span class="n">fn_ub</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">&#8477;</span> <span class="bp">&#8594;</span> <span class="n">&#8477;</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">&#8477;</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="bp">&#8704;</span> <span class="n">x</span><span class="o">,</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">&#8804;</span> <span class="n">a</span>
<span class="kd">def</span> <span class="n">fn_lb</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">&#8477;</span> <span class="bp">&#8594;</span> <span class="n">&#8477;</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">&#8477;</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="bp">&#8704;</span> <span class="n">x</span><span class="o">,</span> <span class="n">a</span> <span class="bp">&#8804;</span> <span class="n">f</span> <span class="n">x</span>

<span class="kd">def</span> <span class="n">fn_has_ub</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">&#8477;</span> <span class="bp">&#8594;</span> <span class="n">&#8477;</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">&#8707;</span> <span class="n">a</span><span class="o">,</span> <span class="n">fn_ub</span> <span class="n">f</span> <span class="n">a</span>
<span class="kd">def</span> <span class="n">fn_has_lb</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">&#8477;</span> <span class="bp">&#8594;</span> <span class="n">&#8477;</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">&#8707;</span> <span class="n">a</span><span class="o">,</span> <span class="n">fn_lb</span> <span class="n">f</span> <span class="n">a</span>
</pre></div>
</div>
</div><p>We can use the theorem <code class="docutils literal notranslate"><span class="pre">fn_ub_add</span></code> from the last section
to prove that if <code class="docutils literal notranslate"><span class="pre">f</span></code> and <code class="docutils literal notranslate"><span class="pre">g</span></code> have upper bounds,
then so does <code class="docutils literal notranslate"><span class="pre">&#955;</span> <span class="pre">x,</span> <span class="pre">f</span> <span class="pre">x</span> <span class="pre">+</span> <span class="pre">g</span> <span class="pre">x</span></code>.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=import%20data.real.basic%0A%0Adef%20fn_ub%20(f%20%3A%20%E2%84%9D%20%E2%86%92%20%E2%84%9D)%20(a%20%3A%20%E2%84%9D)%20%3A%20Prop%20%3A%3D%20%E2%88%80%20x%2C%20f%20x%20%E2%89%A4%20a%0Adef%20fn_lb%20(f%20%3A%20%E2%84%9D%20%E2%86%92%20%E2%84%9D)%20(a%20%3A%20%E2%84%9D)%20%3A%20Prop%20%3A%3D%20%E2%88%80%20x%2C%20a%20%E2%89%A4%20f%20x%0A%0Adef%20fn_has_ub%20(f%20%3A%20%E2%84%9D%20%E2%86%92%20%E2%84%9D)%20%3A%3D%20%E2%88%83%20a%2C%20fn_ub%20f%20a%0Adef%20fn_has_lb%20(f%20%3A%20%E2%84%9D%20%E2%86%92%20%E2%84%9D)%20%3A%3D%20%E2%88%83%20a%2C%20fn_lb%20f%20a%0A%0Atheorem%20fn_ub_add%20%7Bf%20g%20%3A%20%E2%84%9D%20%E2%86%92%20%E2%84%9D%7D%20%7Ba%20b%20%3A%20%E2%84%9D%7D%0A%20%20%20%20(hfa%20%3A%20fn_ub%20f%20a)%20(hgb%20%3A%20fn_ub%20g%20b)%20%3A%0A%20%20fn_ub%20(%CE%BB%20x%2C%20f%20x%20%2B%20g%20x)%20(a%20%2B%20b)%20%3A%3D%0A%CE%BB%20x%2C%20add_le_add%20(hfa%20x)%20(hgb%20x)%0A%0Avariables%20%7Bf%20g%20%3A%20%E2%84%9D%20%E2%86%92%20%E2%84%9D%7D%0A%0A--%20BEGIN%0Aexample%20(ubf%20%3A%20fn_has_ub%20f)%20(ubg%20%3A%20fn_has_ub%20g)%20%3A%0A%20%20fn_has_ub%20(%CE%BB%20x%2C%20f%20x%20%2B%20g%20x)%20%3A%3D%0Abegin%0A%20%20cases%20ubf%20with%20a%20ubfa%2C%0A%20%20cases%20ubg%20with%20b%20ubfb%2C%0A%20%20use%20a%20%2B%20b%2C%0A%20%20apply%20fn_ub_add%20ubfa%20ubfb%0Aend%0A--%20END" target="_blank" tryitfile="../examples/logic/unnamed_623.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span class="kd">example</span> <span class="o">(</span><span class="n">ubf</span> <span class="o">:</span> <span class="n">fn_has_ub</span> <span class="n">f</span><span class="o">)</span> <span class="o">(</span><span class="n">ubg</span> <span class="o">:</span> <span class="n">fn_has_ub</span> <span class="n">g</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">fn_has_ub</span> <span class="o">(</span><span class="bp">&#955;</span> <span class="n">x</span><span class="o">,</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">+</span> <span class="n">g</span> <span class="n">x</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">cases</span> <span class="n">ubf</span> <span class="k">with</span> <span class="n">a</span> <span class="n">ubfa</span><span class="o">,</span>
  <span class="n">cases</span> <span class="n">ubg</span> <span class="k">with</span> <span class="n">b</span> <span class="n">ubfb</span><span class="o">,</span>
  <span class="n">use</span> <span class="n">a</span> <span class="bp">+</span> <span class="n">b</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">fn_ub_add</span> <span class="n">ubfa</span> <span class="n">ubfb</span>
<span class="kd">end</span>
</pre></div>
</div>
</div><p>The <code class="docutils literal notranslate"><span class="pre">cases</span></code> tactic unpacks the information
in the existential quantifier.
Given the hypothesis <code class="docutils literal notranslate"><span class="pre">ubf</span></code> that there is an upper bound
for <code class="docutils literal notranslate"><span class="pre">f</span></code>,
<code class="docutils literal notranslate"><span class="pre">cases</span></code> adds a new variable for an upper
bound to the context,
together with the hypothesis that it has the given property.
The <code class="docutils literal notranslate"><span class="pre">with</span></code> clause allows us to specify the names
we want Lean to use.
The goal is left unchanged;
what <em>has</em> changed is that we can now use
the new object and the new hypothesis
to prove the goal.
This is a common pattern in mathematics:
we unpack objects whose existence is asserted or implied
by some hypothesis, and then use it to establish the existence
of something else.</p>
<p>Try using this pattern to establish the following.
You might find it useful to turn some of the examples
from the last section into named theorems,
as we did with <code class="docutils literal notranslate"><span class="pre">fn_ub_add</span></code>,
or you can insert the arguments directly
into the proofs.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=import%20data.real.basic%0A%0Adef%20fn_ub%20(f%20%3A%20%E2%84%9D%20%E2%86%92%20%E2%84%9D)%20(a%20%3A%20%E2%84%9D)%20%3A%20Prop%20%3A%3D%20%E2%88%80%20x%2C%20f%20x%20%E2%89%A4%20a%0Adef%20fn_lb%20(f%20%3A%20%E2%84%9D%20%E2%86%92%20%E2%84%9D)%20(a%20%3A%20%E2%84%9D)%20%3A%20Prop%20%3A%3D%20%E2%88%80%20x%2C%20a%20%E2%89%A4%20f%20x%0A%0Adef%20fn_has_ub%20(f%20%3A%20%E2%84%9D%20%E2%86%92%20%E2%84%9D)%20%3A%3D%20%E2%88%83%20a%2C%20fn_ub%20f%20a%0Adef%20fn_has_lb%20(f%20%3A%20%E2%84%9D%20%E2%86%92%20%E2%84%9D)%20%3A%3D%20%E2%88%83%20a%2C%20fn_lb%20f%20a%0A%0Avariables%20%7Bf%20g%20%3A%20%E2%84%9D%20%E2%86%92%20%E2%84%9D%7D%0A%0A--%20BEGIN%0Aexample%20(lbf%20%3A%20fn_has_lb%20f)%20(lbg%20%3A%20fn_has_lb%20g)%20%3A%0A%20%20fn_has_lb%20(%CE%BB%20x%2C%20f%20x%20%2B%20g%20x)%20%3A%3D%0Asorry%0A%0Aexample%20%7Bc%20%3A%20%E2%84%9D%7D%20(ubf%20%3A%20fn_has_ub%20f)%20(h%20%3A%20c%20%E2%89%A5%200)%3A%0A%20%20fn_has_ub%20(%CE%BB%20x%2C%20c%20*%20f%20x)%20%3A%3D%0Asorry%0A--%20END" target="_blank" tryitfile="../examples/logic/unnamed_676.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span class="kd">example</span> <span class="o">(</span><span class="n">lbf</span> <span class="o">:</span> <span class="n">fn_has_lb</span> <span class="n">f</span><span class="o">)</span> <span class="o">(</span><span class="n">lbg</span> <span class="o">:</span> <span class="n">fn_has_lb</span> <span class="n">g</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">fn_has_lb</span> <span class="o">(</span><span class="bp">&#955;</span> <span class="n">x</span><span class="o">,</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">+</span> <span class="n">g</span> <span class="n">x</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">sorry</span>

<span class="kd">example</span> <span class="o">{</span><span class="n">c</span> <span class="o">:</span> <span class="n">&#8477;</span><span class="o">}</span> <span class="o">(</span><span class="n">ubf</span> <span class="o">:</span> <span class="n">fn_has_ub</span> <span class="n">f</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">c</span> <span class="bp">&#8805;</span> <span class="mi">0</span><span class="o">):</span>
  <span class="n">fn_has_ub</span> <span class="o">(</span><span class="bp">&#955;</span> <span class="n">x</span><span class="o">,</span> <span class="n">c</span> <span class="bp">*</span> <span class="n">f</span> <span class="n">x</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">sorry</span>
</pre></div>
</div>
</div><p>The task of unpacking information in a hypothesis is
so important that Lean and mathlib provide a number of
ways to do it.
A cousin of the <code class="docutils literal notranslate"><span class="pre">cases</span></code> tactic, <code class="docutils literal notranslate"><span class="pre">rcases</span></code>, is more
flexible in that it allows us to unpack nested data.
(The &#8220;r&#8221; stands for &#8220;recursive.&#8221;)
In the <code class="docutils literal notranslate"><span class="pre">with</span></code> clause for unpacking an existential quantifier,
we name the object and the hypothesis by presenting
them as a pattern <code class="docutils literal notranslate"><span class="pre">&#10216;a,</span> <span class="pre">h&#10217;</span></code> that <code class="docutils literal notranslate"><span class="pre">rcases</span></code> then tries to match.
The <code class="docutils literal notranslate"><span class="pre">rintro</span></code> tactic (which can also be written <code class="docutils literal notranslate"><span class="pre">rintros</span></code>)
is a combination of <code class="docutils literal notranslate"><span class="pre">intros</span></code> and <code class="docutils literal notranslate"><span class="pre">rcases</span></code>.
These examples illustrate their use:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=import%20data.real.basic%0A%0Adef%20fn_ub%20(f%20%3A%20%E2%84%9D%20%E2%86%92%20%E2%84%9D)%20(a%20%3A%20%E2%84%9D)%20%3A%20Prop%20%3A%3D%20%E2%88%80%20x%2C%20f%20x%20%E2%89%A4%20a%0Adef%20fn_lb%20(f%20%3A%20%E2%84%9D%20%E2%86%92%20%E2%84%9D)%20(a%20%3A%20%E2%84%9D)%20%3A%20Prop%20%3A%3D%20%E2%88%80%20x%2C%20a%20%E2%89%A4%20f%20x%0A%0Adef%20fn_has_ub%20(f%20%3A%20%E2%84%9D%20%E2%86%92%20%E2%84%9D)%20%3A%3D%20%E2%88%83%20a%2C%20fn_ub%20f%20a%0Adef%20fn_has_lb%20(f%20%3A%20%E2%84%9D%20%E2%86%92%20%E2%84%9D)%20%3A%3D%20%E2%88%83%20a%2C%20fn_lb%20f%20a%0A%0Avariables%20%7Bf%20g%20%3A%20%E2%84%9D%20%E2%86%92%20%E2%84%9D%7D%0A%0Atheorem%20fn_ub_add%20%7Bf%20g%20%3A%20%E2%84%9D%20%E2%86%92%20%E2%84%9D%7D%20%7Ba%20b%20%3A%20%E2%84%9D%7D%0A%20%20%20%20(hfa%20%3A%20fn_ub%20f%20a)%20(hgb%20%3A%20fn_ub%20g%20b)%20%3A%0A%20%20%20%20fn_ub%20(%CE%BB%20x%2C%20f%20x%20%2B%20g%20x)%20(a%20%2B%20b)%20%3A%3D%0A%CE%BB%20x%2C%20add_le_add%20(hfa%20x)%20(hgb%20x)%0A%0A--%20BEGIN%0Aexample%20(ubf%20%3A%20fn_has_ub%20f)%20(ubg%20%3A%20fn_has_ub%20g)%20%3A%0A%20%20fn_has_ub%20(%CE%BB%20x%2C%20f%20x%20%2B%20g%20x)%20%3A%3D%0Abegin%0A%20%20rcases%20ubf%20with%20%E2%9F%A8a%2C%20ubfa%E2%9F%A9%2C%0A%20%20rcases%20ubg%20with%20%E2%9F%A8b%2C%20ubfb%E2%9F%A9%2C%0A%20%20exact%20%E2%9F%A8a%20%2B%20b%2C%20fn_ub_add%20ubfa%20ubfb%E2%9F%A9%0Aend%0A%0Aexample%20%3A%20fn_has_ub%20f%20%E2%86%92%20fn_has_ub%20g%20%E2%86%92%0A%20%20fn_has_ub%20(%CE%BB%20x%2C%20f%20x%20%2B%20g%20x)%20%3A%3D%0Abegin%0A%20%20rintros%20%E2%9F%A8a%2C%20ubfa%E2%9F%A9%20%E2%9F%A8b%2C%20ubfb%E2%9F%A9%2C%0A%20%20exact%20%E2%9F%A8a%20%2B%20b%2C%20fn_ub_add%20ubfa%20ubfb%E2%9F%A9%0Aend%0A--%20END" target="_blank" tryitfile="../examples/logic/unnamed_711.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span class="kd">example</span> <span class="o">(</span><span class="n">ubf</span> <span class="o">:</span> <span class="n">fn_has_ub</span> <span class="n">f</span><span class="o">)</span> <span class="o">(</span><span class="n">ubg</span> <span class="o">:</span> <span class="n">fn_has_ub</span> <span class="n">g</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">fn_has_ub</span> <span class="o">(</span><span class="bp">&#955;</span> <span class="n">x</span><span class="o">,</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">+</span> <span class="n">g</span> <span class="n">x</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rcases</span> <span class="n">ubf</span> <span class="k">with</span> <span class="o">&#10216;</span><span class="n">a</span><span class="o">,</span> <span class="n">ubfa</span><span class="o">&#10217;,</span>
  <span class="n">rcases</span> <span class="n">ubg</span> <span class="k">with</span> <span class="o">&#10216;</span><span class="n">b</span><span class="o">,</span> <span class="n">ubfb</span><span class="o">&#10217;,</span>
  <span class="n">exact</span> <span class="o">&#10216;</span><span class="n">a</span> <span class="bp">+</span> <span class="n">b</span><span class="o">,</span> <span class="n">fn_ub_add</span> <span class="n">ubfa</span> <span class="n">ubfb</span><span class="o">&#10217;</span>
<span class="kd">end</span>

<span class="kd">example</span> <span class="o">:</span> <span class="n">fn_has_ub</span> <span class="n">f</span> <span class="bp">&#8594;</span> <span class="n">fn_has_ub</span> <span class="n">g</span> <span class="bp">&#8594;</span>
  <span class="n">fn_has_ub</span> <span class="o">(</span><span class="bp">&#955;</span> <span class="n">x</span><span class="o">,</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">+</span> <span class="n">g</span> <span class="n">x</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rintros</span> <span class="o">&#10216;</span><span class="n">a</span><span class="o">,</span> <span class="n">ubfa</span><span class="o">&#10217;</span> <span class="o">&#10216;</span><span class="n">b</span><span class="o">,</span> <span class="n">ubfb</span><span class="o">&#10217;,</span>
  <span class="n">exact</span> <span class="o">&#10216;</span><span class="n">a</span> <span class="bp">+</span> <span class="n">b</span><span class="o">,</span> <span class="n">fn_ub_add</span> <span class="n">ubfa</span> <span class="n">ubfb</span><span class="o">&#10217;</span>
<span class="kd">end</span>
</pre></div>
</div>
</div><p>In fact, Lean also supports a pattern-matching lambda
in expressions and proof terms:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=import%20data.real.basic%0A%0Adef%20fn_ub%20(f%20%3A%20%E2%84%9D%20%E2%86%92%20%E2%84%9D)%20(a%20%3A%20%E2%84%9D)%20%3A%20Prop%20%3A%3D%20%E2%88%80%20x%2C%20f%20x%20%E2%89%A4%20a%0Adef%20fn_lb%20(f%20%3A%20%E2%84%9D%20%E2%86%92%20%E2%84%9D)%20(a%20%3A%20%E2%84%9D)%20%3A%20Prop%20%3A%3D%20%E2%88%80%20x%2C%20a%20%E2%89%A4%20f%20x%0A%0Adef%20fn_has_ub%20(f%20%3A%20%E2%84%9D%20%E2%86%92%20%E2%84%9D)%20%3A%3D%20%E2%88%83%20a%2C%20fn_ub%20f%20a%0Adef%20fn_has_lb%20(f%20%3A%20%E2%84%9D%20%E2%86%92%20%E2%84%9D)%20%3A%3D%20%E2%88%83%20a%2C%20fn_lb%20f%20a%0A%0Avariables%20%7Bf%20g%20%3A%20%E2%84%9D%20%E2%86%92%20%E2%84%9D%7D%0A%0Atheorem%20fn_ub_add%20%7Bf%20g%20%3A%20%E2%84%9D%20%E2%86%92%20%E2%84%9D%7D%20%7Ba%20b%20%3A%20%E2%84%9D%7D%0A%20%20%20%20(hfa%20%3A%20fn_ub%20f%20a)%20(hgb%20%3A%20fn_ub%20g%20b)%20%3A%0A%20%20%20%20fn_ub%20(%CE%BB%20x%2C%20f%20x%20%2B%20g%20x)%20(a%20%2B%20b)%20%3A%3D%0A%CE%BB%20x%2C%20add_le_add%20(hfa%20x)%20(hgb%20x)%0A%0A--%20BEGIN%0Aexample%20%3A%20fn_has_ub%20f%20%E2%86%92%20fn_has_ub%20g%20%E2%86%92%0A%20%20fn_has_ub%20(%CE%BB%20x%2C%20f%20x%20%2B%20g%20x)%20%3A%3D%0A%CE%BB%20%E2%9F%A8a%2C%20ubfa%E2%9F%A9%20%E2%9F%A8b%2C%20ubfb%E2%9F%A9%2C%20%E2%9F%A8a%20%2B%20b%2C%20fn_ub_add%20ubfa%20ubfb%E2%9F%A9%0A--%20END" target="_blank" tryitfile="../examples/logic/unnamed_748.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span class="kd">example</span> <span class="o">:</span> <span class="n">fn_has_ub</span> <span class="n">f</span> <span class="bp">&#8594;</span> <span class="n">fn_has_ub</span> <span class="n">g</span> <span class="bp">&#8594;</span>
  <span class="n">fn_has_ub</span> <span class="o">(</span><span class="bp">&#955;</span> <span class="n">x</span><span class="o">,</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">+</span> <span class="n">g</span> <span class="n">x</span><span class="o">)</span> <span class="o">:=</span>
<span class="bp">&#955;</span> <span class="o">&#10216;</span><span class="n">a</span><span class="o">,</span> <span class="n">ubfa</span><span class="o">&#10217;</span> <span class="o">&#10216;</span><span class="n">b</span><span class="o">,</span> <span class="n">ubfb</span><span class="o">&#10217;,</span> <span class="o">&#10216;</span><span class="n">a</span> <span class="bp">+</span> <span class="n">b</span><span class="o">,</span> <span class="n">fn_ub_add</span> <span class="n">ubfa</span> <span class="n">ubfb</span><span class="o">&#10217;</span>
</pre></div>
</div>
</div><p>These are power-user moves, and there is no harm
in favoring the use of <code class="docutils literal notranslate"><span class="pre">cases</span></code> until you are more comfortable
with the existential quantifier.
But we will come to learn that all of these tools,
including <code class="docutils literal notranslate"><span class="pre">cases</span></code>, use, and the anonymous constructors,
are like Swiss army knives when it comes to theorem proving.
They can be used for a wide range of purposes,
not just for unpacking exists statements.</p>
<p>To illustrate one way that <code class="docutils literal notranslate"><span class="pre">rcases</span></code> can be used,
we prove an old mathematical chestnut:
if two integers <code class="docutils literal notranslate"><span class="pre">x</span></code> and <code class="docutils literal notranslate"><span class="pre">y</span></code> can each be written as
a sum of two squares,
then so can their product, <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">*</span> <span class="pre">y</span></code>.
In fact, the statement is true for any commutative
ring, not just the integers.
In the next example, <code class="docutils literal notranslate"><span class="pre">rcases</span></code> unpacks two existential
quantifiers at once.
We then provide the magic values needed to express <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">*</span> <span class="pre">y</span></code>
as a sum of squares as a list to the <code class="docutils literal notranslate"><span class="pre">use</span></code> statement,
and we use <code class="docutils literal notranslate"><span class="pre">ring</span></code> to verify that they work.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=import%20tactic%0A%0Avariables%20%7B%CE%B1%20%3A%20Type*%7D%20%5Bcomm_ring%20%CE%B1%5D%0A%0Adef%20sum_of_squares%20(x%20%3A%20%CE%B1)%20%3A%3D%20%E2%88%83%20a%20b%2C%20x%20%3D%20a%5E2%20%2B%20b%5E2%0A%0Atheorem%20sum_of_squares_mul%20%7Bx%20y%20%3A%20%CE%B1%7D%0A%20%20%20%20(sosx%20%3A%20sum_of_squares%20x)%20(sosy%20%3A%20sum_of_squares%20y)%20%3A%0A%20%20sum_of_squares%20(x%20*%20y)%20%3A%3D%0Abegin%0A%20%20rcases%20sosx%20with%20%E2%9F%A8a%2C%20b%2C%20xeq%E2%9F%A9%2C%0A%20%20rcases%20sosy%20with%20%E2%9F%A8c%2C%20d%2C%20yeq%E2%9F%A9%2C%0A%20%20rw%20%5Bxeq%2C%20yeq%5D%2C%0A%20%20use%20%5Ba*c%20-%20b*d%2C%20a*d%20%2B%20b*c%5D%2C%0A%20%20ring%0Aend" target="_blank" tryitfile="../examples/logic/unnamed_793.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span class="kn">import</span> <span class="n">tactic</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">&#945;</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">comm_ring</span> <span class="n">&#945;</span><span class="o">]</span>

<span class="kd">def</span> <span class="n">sum_of_squares</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">&#945;</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">&#8707;</span> <span class="n">a</span> <span class="n">b</span><span class="o">,</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">a</span><span class="bp">^</span><span class="mi">2</span> <span class="bp">+</span> <span class="n">b</span><span class="bp">^</span><span class="mi">2</span>

<span class="kd">theorem</span> <span class="n">sum_of_squares_mul</span> <span class="o">{</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">&#945;</span><span class="o">}</span>
    <span class="o">(</span><span class="n">sosx</span> <span class="o">:</span> <span class="n">sum_of_squares</span> <span class="n">x</span><span class="o">)</span> <span class="o">(</span><span class="n">sosy</span> <span class="o">:</span> <span class="n">sum_of_squares</span> <span class="n">y</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">sum_of_squares</span> <span class="o">(</span><span class="n">x</span> <span class="bp">*</span> <span class="n">y</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rcases</span> <span class="n">sosx</span> <span class="k">with</span> <span class="o">&#10216;</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">xeq</span><span class="o">&#10217;,</span>
  <span class="n">rcases</span> <span class="n">sosy</span> <span class="k">with</span> <span class="o">&#10216;</span><span class="n">c</span><span class="o">,</span> <span class="n">d</span><span class="o">,</span> <span class="n">yeq</span><span class="o">&#10217;,</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">xeq</span><span class="o">,</span> <span class="n">yeq</span><span class="o">],</span>
  <span class="n">use</span> <span class="o">[</span><span class="n">a</span><span class="bp">*</span><span class="n">c</span> <span class="bp">-</span> <span class="n">b</span><span class="bp">*</span><span class="n">d</span><span class="o">,</span> <span class="n">a</span><span class="bp">*</span><span class="n">d</span> <span class="bp">+</span> <span class="n">b</span><span class="bp">*</span><span class="n">c</span><span class="o">],</span>
  <span class="n">ring</span>
<span class="kd">end</span>
</pre></div>
</div>
</div><p>This proof doesn&#8217;t provide much insight,
but here is one way to motivate it.
A <em>Gaussian integer</em> is a number of the form <span class="math notranslate nohighlight">\(a + bi\)</span>
where <span class="math notranslate nohighlight">\(a\)</span> and <span class="math notranslate nohighlight">\(b\)</span> are integers and <span class="math notranslate nohighlight">\(i = \sqrt{-1}\)</span>.
The <em>norm</em> of the Gaussian integer <span class="math notranslate nohighlight">\(a + bi\)</span> is, by definition,
<span class="math notranslate nohighlight">\(a^2 + b^2\)</span>.
So the norm of a Gaussian integer is a sum of squares,
and any sum of squares can be expressed in this way.
The theorem above reflects the fact that norm of a product of
Gaussian integers is the product of their norms:
if <span class="math notranslate nohighlight">\(x\)</span> is the norm of <span class="math notranslate nohighlight">\(a + bi\)</span> and
<span class="math notranslate nohighlight">\(y\)</span> in the norm of <span class="math notranslate nohighlight">\(c + di\)</span>,
then <span class="math notranslate nohighlight">\(xy\)</span> is the norm of <span class="math notranslate nohighlight">\((a + bi) (c + di)\)</span>.
Our cryptic proof illustrates the fact that
the proof that is easiest to formalize isn&#8217;t always
the most perspicuous one.
In the chapters to come,
we will provide you with the means to define the Gaussian
integers and use them to provide an alternative proof.</p>
<p>The pattern of unpacking an equation inside a existential quantifier
and then using it to rewrite an expression in the goal
comes up often,
so much so that the <code class="docutils literal notranslate"><span class="pre">rcases</span></code> tactic provides
an abbreviation:
if you use the keyword <code class="docutils literal notranslate"><span class="pre">rfl</span></code> in place of a new identifier,
<code class="docutils literal notranslate"><span class="pre">rcases</span></code> does the rewriting automatically.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=import%20tactic%0A%0Avariables%20%7B%CE%B1%20%3A%20Type*%7D%20%5Bcomm_ring%20%CE%B1%5D%0A%0Adef%20sum_of_squares%20(x%20%3A%20%CE%B1)%20%3A%3D%20%E2%88%83%20a%20b%2C%20x%20%3D%20a%5E2%20%2B%20b%5E2%0A%0A--%20BEGIN%0Atheorem%20sum_of_squares_mul%20%7Bx%20y%20%3A%20%CE%B1%7D%0A%20%20%20%20(sosx%20%3A%20sum_of_squares%20x)%20(sosy%20%3A%20sum_of_squares%20y)%20%3A%0A%20%20sum_of_squares%20(x%20*%20y)%20%3A%3D%0Abegin%0A%20%20rcases%20sosx%20with%20%E2%9F%A8a%2C%20b%2C%20rfl%E2%9F%A9%2C%0A%20%20rcases%20sosy%20with%20%E2%9F%A8c%2C%20d%2C%20rfl%E2%9F%A9%2C%0A%20%20use%20%5Ba*c%20-%20b*d%2C%20a*d%20%2B%20b*c%5D%2C%0A%20%20ring%0Aend%0A--%20END" target="_blank" tryitfile="../examples/logic/unnamed_840.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span class="kd">theorem</span> <span class="n">sum_of_squares_mul</span> <span class="o">{</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">&#945;</span><span class="o">}</span>
    <span class="o">(</span><span class="n">sosx</span> <span class="o">:</span> <span class="n">sum_of_squares</span> <span class="n">x</span><span class="o">)</span> <span class="o">(</span><span class="n">sosy</span> <span class="o">:</span> <span class="n">sum_of_squares</span> <span class="n">y</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">sum_of_squares</span> <span class="o">(</span><span class="n">x</span> <span class="bp">*</span> <span class="n">y</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rcases</span> <span class="n">sosx</span> <span class="k">with</span> <span class="o">&#10216;</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">rfl</span><span class="o">&#10217;,</span>
  <span class="n">rcases</span> <span class="n">sosy</span> <span class="k">with</span> <span class="o">&#10216;</span><span class="n">c</span><span class="o">,</span> <span class="n">d</span><span class="o">,</span> <span class="n">rfl</span><span class="o">&#10217;,</span>
  <span class="n">use</span> <span class="o">[</span><span class="n">a</span><span class="bp">*</span><span class="n">c</span> <span class="bp">-</span> <span class="n">b</span><span class="bp">*</span><span class="n">d</span><span class="o">,</span> <span class="n">a</span><span class="bp">*</span><span class="n">d</span> <span class="bp">+</span> <span class="n">b</span><span class="bp">*</span><span class="n">c</span><span class="o">],</span>
  <span class="n">ring</span>
<span class="kd">end</span>
</pre></div>
</div>
</div><p>As with the universal quantifier,
you can find existential quantifiers hidden all over
if you know how to spot them.
For example, divisibility is implicitly an &#8220;exists&#8221; statement.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=import%20tactic%0A%0Avariables%20%7Ba%20b%20c%20%3A%20%E2%84%95%7D%0A%0A--%20BEGIN%0Aexample%20(divab%20%3A%20a%20%E2%88%A3%20b)%20(divbc%20%3A%20b%20%E2%88%A3%20c)%20%3A%20a%20%E2%88%A3%20c%20%3A%3D%0Abegin%0A%20%20cases%20divab%20with%20d%20beq%2C%0A%20%20cases%20divbc%20with%20e%20ceq%2C%0A%20%20rw%20%5Bceq%2C%20beq%5D%2C%0A%20%20use%20(d%20*%20e)%2C%20ring%0Aend%0A--%20END" target="_blank" tryitfile="../examples/logic/unnamed_865.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span class="kd">example</span> <span class="o">(</span><span class="n">divab</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">&#8739;</span> <span class="n">b</span><span class="o">)</span> <span class="o">(</span><span class="n">divbc</span> <span class="o">:</span> <span class="n">b</span> <span class="bp">&#8739;</span> <span class="n">c</span><span class="o">)</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">&#8739;</span> <span class="n">c</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">cases</span> <span class="n">divab</span> <span class="k">with</span> <span class="n">d</span> <span class="n">beq</span><span class="o">,</span>
  <span class="n">cases</span> <span class="n">divbc</span> <span class="k">with</span> <span class="n">e</span> <span class="n">ceq</span><span class="o">,</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">ceq</span><span class="o">,</span> <span class="n">beq</span><span class="o">],</span>
  <span class="n">use</span> <span class="o">(</span><span class="n">d</span> <span class="bp">*</span> <span class="n">e</span><span class="o">),</span> <span class="n">ring</span>
<span class="kd">end</span>
</pre></div>
</div>
</div><p>And once again, this provides a nice setting for using
<code class="docutils literal notranslate"><span class="pre">rcases</span></code> with <code class="docutils literal notranslate"><span class="pre">rfl</span></code>.
Try it out in the proof above.
It feels pretty good!</p>
<p>Then try proving the following:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=import%20tactic%0A%0Avariables%20%7Ba%20b%20c%20%3A%20%E2%84%95%7D%0A%0A--%20BEGIN%0Aexample%20(divab%20%3A%20a%20%E2%88%A3%20b)%20(divac%20%3A%20a%20%E2%88%A3%20c)%20%3A%20a%20%E2%88%A3%20(b%20%2B%20c)%20%3A%3D%0Asorry%0A--%20END" target="_blank" tryitfile="../examples/logic/unnamed_888.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span class="kd">example</span> <span class="o">(</span><span class="n">divab</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">&#8739;</span> <span class="n">b</span><span class="o">)</span> <span class="o">(</span><span class="n">divac</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">&#8739;</span> <span class="n">c</span><span class="o">)</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">&#8739;</span> <span class="o">(</span><span class="n">b</span> <span class="bp">+</span> <span class="n">c</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">sorry</span>
</pre></div>
</div>
</div><p>For another important example, a function <span class="math notranslate nohighlight">\(f : \alpha \to \beta\)</span>
is said to be <em>surjective</em> if for every <span class="math notranslate nohighlight">\(y\)</span> in the
codomain, <span class="math notranslate nohighlight">\(\beta\)</span>,
there is an <span class="math notranslate nohighlight">\(x\)</span> in the domain, <span class="math notranslate nohighlight">\(\alpha\)</span>,
such that <span class="math notranslate nohighlight">\(f(x) = y\)</span>.
Notice that this statement includes both a universal
and an existential quantifier, which explains
why the next example makes use of both <code class="docutils literal notranslate"><span class="pre">intro</span></code> and <code class="docutils literal notranslate"><span class="pre">use</span></code>.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=import%20data.real.basic%0A%0Aopen%20function%0A%0A--%20BEGIN%0Aexample%20%7Bc%20%3A%20%E2%84%9D%7D%20%3A%20surjective%20(%CE%BB%20x%2C%20x%20%2B%20c)%20%3A%3D%0Abegin%0A%20%20intro%20x%2C%0A%20%20use%20x%20-%20c%2C%0A%20%20dsimp%2C%20ring%0Aend%0A--%20END" target="_blank" tryitfile="../examples/logic/unnamed_908.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span class="kd">example</span> <span class="o">{</span><span class="n">c</span> <span class="o">:</span> <span class="n">&#8477;</span><span class="o">}</span> <span class="o">:</span> <span class="n">surjective</span> <span class="o">(</span><span class="bp">&#955;</span> <span class="n">x</span><span class="o">,</span> <span class="n">x</span> <span class="bp">+</span> <span class="n">c</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">intro</span> <span class="n">x</span><span class="o">,</span>
  <span class="n">use</span> <span class="n">x</span> <span class="bp">-</span> <span class="n">c</span><span class="o">,</span>
  <span class="n">dsimp</span><span class="o">,</span> <span class="n">ring</span>
<span class="kd">end</span>
</pre></div>
</div>
</div><p>Try this example yourself:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=import%20data.real.basic%0A%0Aopen%20function%0A%0A--%20BEGIN%0Aexample%20%7Bc%20%3A%20%E2%84%9D%7D%20(h%20%3A%20c%20%E2%89%A0%200)%20%3A%20surjective%20(%CE%BB%20x%2C%20c%20*%20x)%20%3A%3D%0Asorry%0A--%20END" target="_blank" tryitfile="../examples/logic/unnamed_925.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span class="kd">example</span> <span class="o">{</span><span class="n">c</span> <span class="o">:</span> <span class="n">&#8477;</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">c</span> <span class="bp">&#8800;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">:</span> <span class="n">surjective</span> <span class="o">(</span><span class="bp">&#955;</span> <span class="n">x</span><span class="o">,</span> <span class="n">c</span> <span class="bp">*</span> <span class="n">x</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">sorry</span>
</pre></div>
</div>
</div><p>You can use the theorem <code class="docutils literal notranslate"><span class="pre">div_mul_cancel</span></code>.
The next example uses a surjectivity hypothesis
by applying it to a suitable value.
Note that you can use <code class="docutils literal notranslate"><span class="pre">cases</span></code> with any expression,
not just a hypothesis.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=import%20data.real.basic%0A%0Aopen%20function%0A%0A--%20BEGIN%0Aexample%20%7Bf%20%3A%20%E2%84%9D%20%E2%86%92%20%E2%84%9D%7D%20(h%20%3A%20surjective%20f)%20%3A%20%E2%88%83%20x%2C%20(f%20x)%5E2%20%3D%204%20%3A%3D%0Abegin%0A%20%20cases%20h%202%20with%20x%20hx%2C%0A%20%20use%20x%2C%0A%20%20rw%20hx%2C%0A%20%20norm_num%0Aend%0A--%20END" target="_blank" tryitfile="../examples/logic/unnamed_942.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span class="kd">example</span> <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">&#8477;</span> <span class="bp">&#8594;</span> <span class="n">&#8477;</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">surjective</span> <span class="n">f</span><span class="o">)</span> <span class="o">:</span> <span class="bp">&#8707;</span> <span class="n">x</span><span class="o">,</span> <span class="o">(</span><span class="n">f</span> <span class="n">x</span><span class="o">)</span><span class="bp">^</span><span class="mi">2</span> <span class="bp">=</span> <span class="mi">4</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">cases</span> <span class="n">h</span> <span class="mi">2</span> <span class="k">with</span> <span class="n">x</span> <span class="n">hx</span><span class="o">,</span>
  <span class="n">use</span> <span class="n">x</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">hx</span><span class="o">,</span>
  <span class="n">norm_num</span>
<span class="kd">end</span>
</pre></div>
</div>
</div><p>See if you can use these methods to show that
the composition of surjective functions is surjective.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=import%20tactic%0A%0Aopen%20function%0A%0Avariables%20%7B%CE%B1%20%3A%20Type*%7D%20%7B%CE%B2%20%3A%20Type*%7D%20%7B%CE%B3%20%3A%20Type*%7D%0Avariables%20%7Bg%20%3A%20%CE%B2%20%E2%86%92%20%CE%B3%7D%20%7Bf%20%3A%20%CE%B1%20%E2%86%92%20%CE%B2%7D%0A%0A--%20BEGIN%0Aexample%20(surjg%20%3A%20surjective%20g)%20(surjf%20%3A%20surjective%20f)%20%3A%0A%20%20surjective%20(%CE%BB%20x%2C%20g%20(f%20x))%20%3A%3D%0Asorry%0A--%20END" target="_blank" tryitfile="../examples/logic/unnamed_961.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span class="kd">example</span> <span class="o">(</span><span class="n">surjg</span> <span class="o">:</span> <span class="n">surjective</span> <span class="n">g</span><span class="o">)</span> <span class="o">(</span><span class="n">surjf</span> <span class="o">:</span> <span class="n">surjective</span> <span class="n">f</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">surjective</span> <span class="o">(</span><span class="bp">&#955;</span> <span class="n">x</span><span class="o">,</span> <span class="n">g</span> <span class="o">(</span><span class="n">f</span> <span class="n">x</span><span class="o">))</span> <span class="o">:=</span>
<span class="n">sorry</span>
</pre></div>
</div>
</div></div>
<div class="section" id="negation">
<span id="id4"></span><h2><span class="section-number">3.3. </span>Negation<a class="headerlink" href="#negation" title="Permalink to this headline">&#182;</a></h2>
<p>The symbol <code class="docutils literal notranslate"><span class="pre">&#172;</span></code> is meant to express negation,
so <code class="docutils literal notranslate"><span class="pre">&#172;</span> <span class="pre">x</span> <span class="pre">&lt;</span> <span class="pre">y</span></code> says that <code class="docutils literal notranslate"><span class="pre">x</span></code> is not less than <code class="docutils literal notranslate"><span class="pre">y</span></code>,
<code class="docutils literal notranslate"><span class="pre">&#172;</span> <span class="pre">x</span> <span class="pre">=</span> <span class="pre">y</span></code> (or, equivalently, <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">&#8800;</span> <span class="pre">y</span></code>) says that
<code class="docutils literal notranslate"><span class="pre">x</span></code> is not equal to <code class="docutils literal notranslate"><span class="pre">y</span></code>,
and <code class="docutils literal notranslate"><span class="pre">&#172;</span> <span class="pre">&#8707;</span> <span class="pre">z,</span> <span class="pre">x</span> <span class="pre">&lt;</span> <span class="pre">z</span> <span class="pre">&#8743;</span> <span class="pre">z</span> <span class="pre">&lt;</span> <span class="pre">y</span></code> says that there does not exist a <code class="docutils literal notranslate"><span class="pre">z</span></code>
strictly between <code class="docutils literal notranslate"><span class="pre">x</span></code> and <code class="docutils literal notranslate"><span class="pre">y</span></code>.
In Lean, the notation <code class="docutils literal notranslate"><span class="pre">&#172;</span> <span class="pre">A</span></code> abbreviates <code class="docutils literal notranslate"><span class="pre">A</span> <span class="pre">&#8594;</span> <span class="pre">false</span></code>,
which you can think of as saying that <code class="docutils literal notranslate"><span class="pre">A</span></code> implies a contradiction.
Practically speaking, this means that you already know something
about how to work with negations:
you can prove <code class="docutils literal notranslate"><span class="pre">&#172;</span> <span class="pre">A</span></code> by introducing a hypothesis <code class="docutils literal notranslate"><span class="pre">h</span> <span class="pre">:</span> <span class="pre">A</span></code>
and proving <code class="docutils literal notranslate"><span class="pre">false</span></code>,
and if you have <code class="docutils literal notranslate"><span class="pre">h</span> <span class="pre">:</span> <span class="pre">&#172;</span> <span class="pre">A</span></code> and <code class="docutils literal notranslate"><span class="pre">h'</span> <span class="pre">:</span> <span class="pre">A</span></code>,
then applying <code class="docutils literal notranslate"><span class="pre">h</span></code> to <code class="docutils literal notranslate"><span class="pre">h'</span></code> yields <code class="docutils literal notranslate"><span class="pre">false</span></code>.</p>
<p>To illustrate, consider the irreflexivity principle <code class="docutils literal notranslate"><span class="pre">lt_irrefl</span></code>
for a strict order,
which says that we have <code class="docutils literal notranslate"><span class="pre">&#172;</span> <span class="pre">a</span> <span class="pre">&lt;</span> <span class="pre">a</span></code> for every <code class="docutils literal notranslate"><span class="pre">a</span></code>.
The asymmetry principle <code class="docutils literal notranslate"><span class="pre">lt_asymm</span></code> says that we have
<code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">&lt;</span> <span class="pre">b</span> <span class="pre">&#8594;</span> <span class="pre">&#172;</span> <span class="pre">b</span> <span class="pre">&lt;</span> <span class="pre">a</span></code>. Let&#8217;s show that <code class="docutils literal notranslate"><span class="pre">lt_asymm</span></code> follows
from <code class="docutils literal notranslate"><span class="pre">lt_irrefl</span></code>.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=import%20data.real.basic%0A%0Avariables%20a%20b%20%3A%20%E2%84%9D%0A%0A--%20BEGIN%0Aexample%20(h%20%3A%20a%20%3C%20b)%20%3A%20%C2%AC%20b%20%3C%20a%20%3A%3D%0Abegin%0A%20%20intro%20h'%2C%0A%20%20have%20%3A%20a%20%3C%20a%2C%0A%20%20%20%20from%20lt_trans%20h%20h'%2C%0A%20%20apply%20lt_irrefl%20a%20this%0Aend%0A--%20END" target="_blank" tryitfile="../examples/logic/unnamed_1003.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span class="kd">example</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">&lt;</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span> <span class="bp">&#172;</span> <span class="n">b</span> <span class="bp">&lt;</span> <span class="n">a</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">intro</span> <span class="n">h&#39;</span><span class="o">,</span>
  <span class="k">have</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">&lt;</span> <span class="n">a</span><span class="o">,</span>
    <span class="k">from</span> <span class="n">lt_trans</span> <span class="n">h</span> <span class="n">h&#39;</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">lt_irrefl</span> <span class="n">a</span> <span class="n">this</span>
<span class="kd">end</span>
</pre></div>
</div>
</div><p>This example introduces a couple of new tricks.
First, when you use <code class="docutils literal notranslate"><span class="pre">have</span></code> without providing
a label,
Lean uses the name <code class="docutils literal notranslate"><span class="pre">this</span></code>,
providing a convenient way to refer back to it.
Also, the <code class="docutils literal notranslate"><span class="pre">from</span></code> tactic is syntactic sugar for <code class="docutils literal notranslate"><span class="pre">exact</span></code>,
providing a nice way to justify a <code class="docutils literal notranslate"><span class="pre">have</span></code> with an explicit
proof term.
But what you should really be paying attention to in this
proof is the result of the <code class="docutils literal notranslate"><span class="pre">intro</span></code> tactic,
which leaves a goal of <code class="docutils literal notranslate"><span class="pre">false</span></code>,
and the fact that we eventually prove <code class="docutils literal notranslate"><span class="pre">false</span></code>
by applying <code class="docutils literal notranslate"><span class="pre">lt_irrefl</span></code> to a proof of <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">&lt;</span> <span class="pre">a</span></code>.</p>
<p>Here is another example, which uses the
predicate <code class="docutils literal notranslate"><span class="pre">fn_has_ub</span></code> defined in the last section,
which says that a function has an upper bound.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=import%20data.real.basic%0A%0Adef%20fn_ub%20(f%20%3A%20%E2%84%9D%20%E2%86%92%20%E2%84%9D)%20(a%20%3A%20%E2%84%9D)%20%3A%20Prop%20%3A%3D%20%E2%88%80%20x%2C%20f%20x%20%E2%89%A4%20a%0A%0Adef%20fn_has_ub%20(f%20%3A%20%E2%84%9D%20%E2%86%92%20%E2%84%9D)%20%3A%3D%20%E2%88%83%20a%2C%20fn_ub%20f%20a%0A%0Avariable%20f%20%3A%20%E2%84%9D%20%E2%86%92%20%E2%84%9D%0A%0A--%20BEGIN%0Aexample%20(h%20%3A%20%E2%88%80%20a%2C%20%E2%88%83%20x%2C%20f%20x%20%3E%20a)%20%3A%20%C2%AC%20fn_has_ub%20f%20%3A%3D%0Abegin%0A%20%20intros%20fnub%2C%0A%20%20cases%20fnub%20with%20a%20fnuba%2C%0A%20%20cases%20h%20a%20with%20x%20hx%2C%0A%20%20have%20%3A%20f%20x%20%E2%89%A4%20a%2C%0A%20%20%20%20from%20fnuba%20x%2C%0A%20%20linarith%0Aend%0A--%20END" target="_blank" tryitfile="../examples/logic/unnamed_1037.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span class="kd">example</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">&#8704;</span> <span class="n">a</span><span class="o">,</span> <span class="bp">&#8707;</span> <span class="n">x</span><span class="o">,</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">&gt;</span> <span class="n">a</span><span class="o">)</span> <span class="o">:</span> <span class="bp">&#172;</span> <span class="n">fn_has_ub</span> <span class="n">f</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">intros</span> <span class="n">fnub</span><span class="o">,</span>
  <span class="n">cases</span> <span class="n">fnub</span> <span class="k">with</span> <span class="n">a</span> <span class="n">fnuba</span><span class="o">,</span>
  <span class="n">cases</span> <span class="n">h</span> <span class="n">a</span> <span class="k">with</span> <span class="n">x</span> <span class="n">hx</span><span class="o">,</span>
  <span class="k">have</span> <span class="o">:</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">&#8804;</span> <span class="n">a</span><span class="o">,</span>
    <span class="k">from</span> <span class="n">fnuba</span> <span class="n">x</span><span class="o">,</span>
  <span class="n">linarith</span>
<span class="kd">end</span>
</pre></div>
</div>
</div><p>See if you can prove these in a similar way:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=import%20data.real.basic%0A%0Adef%20fn_ub%20(f%20%3A%20%E2%84%9D%20%E2%86%92%20%E2%84%9D)%20(a%20%3A%20%E2%84%9D)%20%3A%20Prop%20%3A%3D%20%E2%88%80%20x%2C%20f%20x%20%E2%89%A4%20a%0Adef%20fn_lb%20(f%20%3A%20%E2%84%9D%20%E2%86%92%20%E2%84%9D)%20(a%20%3A%20%E2%84%9D)%20%3A%20Prop%20%3A%3D%20%E2%88%80%20x%2C%20a%20%E2%89%A4%20f%20x%0A%0Adef%20fn_has_ub%20(f%20%3A%20%E2%84%9D%20%E2%86%92%20%E2%84%9D)%20%3A%3D%20%E2%88%83%20a%2C%20fn_ub%20f%20a%0Adef%20fn_has_lb%20(f%20%3A%20%E2%84%9D%20%E2%86%92%20%E2%84%9D)%20%3A%3D%20%E2%88%83%20a%2C%20fn_lb%20f%20a%0A%0Avariable%20f%20%3A%20%E2%84%9D%20%E2%86%92%20%E2%84%9D%0A%0A--%20BEGIN%0Aexample%20(h%20%3A%20%E2%88%80%20a%2C%20%E2%88%83%20x%2C%20f%20x%20%3C%20a)%20%3A%20%C2%AC%20fn_has_lb%20f%20%3A%3D%0Asorry%0A%0Aexample%20%3A%20%C2%AC%20fn_has_ub%20(%CE%BB%20x%2C%20x)%20%3A%3D%0Asorry%0A--%20END" target="_blank" tryitfile="../examples/logic/unnamed_1061.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span class="kd">example</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">&#8704;</span> <span class="n">a</span><span class="o">,</span> <span class="bp">&#8707;</span> <span class="n">x</span><span class="o">,</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">&lt;</span> <span class="n">a</span><span class="o">)</span> <span class="o">:</span> <span class="bp">&#172;</span> <span class="n">fn_has_lb</span> <span class="n">f</span> <span class="o">:=</span>
<span class="n">sorry</span>

<span class="kd">example</span> <span class="o">:</span> <span class="bp">&#172;</span> <span class="n">fn_has_ub</span> <span class="o">(</span><span class="bp">&#955;</span> <span class="n">x</span><span class="o">,</span> <span class="n">x</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">sorry</span>
</pre></div>
</div>
</div><p>Mathlib offers a number of useful theorems for relating orders
and negations:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=import%20data.real.basic%0A%0Avariables%20a%20b%20%3A%20%E2%84%9D%0A%0A--%20BEGIN%0A%23check%20(not_le_of_gt%20%3A%20a%20%3E%20b%20%E2%86%92%20%C2%AC%20a%20%E2%89%A4%20b)%0A%23check%20(not_lt_of_ge%20%3A%20a%20%E2%89%A5%20b%20%E2%86%92%20%C2%AC%20a%20%3C%20b)%0A%23check%20(lt_of_not_ge%20%3A%20%C2%AC%20a%20%E2%89%A5%20b%20%E2%86%92%20a%20%3C%20b)%0A%23check%20(le_of_not_gt%20%3A%20%C2%AC%20a%20%3E%20b%20%E2%86%92%20a%20%E2%89%A4%20b)%0A--%20END" target="_blank" tryitfile="../examples/logic/unnamed_1084.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span class="k">#check</span> <span class="o">(</span><span class="n">not_le_of_gt</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">&gt;</span> <span class="n">b</span> <span class="bp">&#8594;</span> <span class="bp">&#172;</span> <span class="n">a</span> <span class="bp">&#8804;</span> <span class="n">b</span><span class="o">)</span>
<span class="k">#check</span> <span class="o">(</span><span class="n">not_lt_of_ge</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">&#8805;</span> <span class="n">b</span> <span class="bp">&#8594;</span> <span class="bp">&#172;</span> <span class="n">a</span> <span class="bp">&lt;</span> <span class="n">b</span><span class="o">)</span>
<span class="k">#check</span> <span class="o">(</span><span class="n">lt_of_not_ge</span> <span class="o">:</span> <span class="bp">&#172;</span> <span class="n">a</span> <span class="bp">&#8805;</span> <span class="n">b</span> <span class="bp">&#8594;</span> <span class="n">a</span> <span class="bp">&lt;</span> <span class="n">b</span><span class="o">)</span>
<span class="k">#check</span> <span class="o">(</span><span class="n">le_of_not_gt</span> <span class="o">:</span> <span class="bp">&#172;</span> <span class="n">a</span> <span class="bp">&gt;</span> <span class="n">b</span> <span class="bp">&#8594;</span> <span class="n">a</span> <span class="bp">&#8804;</span> <span class="n">b</span><span class="o">)</span>
</pre></div>
</div>
</div><p>Recall the predicate <code class="docutils literal notranslate"><span class="pre">monotone</span> <span class="pre">f</span></code>,
which says that <code class="docutils literal notranslate"><span class="pre">f</span></code> is nondecreasing.
Use some of the theorems just enumerated to prove the following:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=import%20data.real.basic%0A%0Avariables%20(f%20%3A%20%E2%84%9D%20%E2%86%92%20%E2%84%9D)%20(a%20b%20%3A%20%E2%84%9D)%0A%0A--%20BEGIN%0Aexample%20(h%20%3A%20monotone%20f)%20(h'%20%3A%20f%20a%20%3C%20f%20b)%20%3A%20a%20%3C%20b%20%3A%3D%0Asorry%0A%0Aexample%20(h%20%3A%20a%20%E2%89%A4%20b)%20(h'%20%3A%20f%20b%20%3C%20f%20a)%20%3A%20%C2%AC%20monotone%20f%20%3A%3D%0Asorry%0A--%20END" target="_blank" tryitfile="../examples/logic/unnamed_1101.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span class="kd">example</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">monotone</span> <span class="n">f</span><span class="o">)</span> <span class="o">(</span><span class="n">h&#39;</span> <span class="o">:</span> <span class="n">f</span> <span class="n">a</span> <span class="bp">&lt;</span> <span class="n">f</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">&lt;</span> <span class="n">b</span> <span class="o">:=</span>
<span class="n">sorry</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">&#8804;</span> <span class="n">b</span><span class="o">)</span> <span class="o">(</span><span class="n">h&#39;</span> <span class="o">:</span> <span class="n">f</span> <span class="n">b</span> <span class="bp">&lt;</span> <span class="n">f</span> <span class="n">a</span><span class="o">)</span> <span class="o">:</span> <span class="bp">&#172;</span> <span class="n">monotone</span> <span class="n">f</span> <span class="o">:=</span>
<span class="n">sorry</span>
</pre></div>
</div>
</div><p>Remember that it is often convenient to use <code class="docutils literal notranslate"><span class="pre">linarith</span></code>
when a goal follows from linear equations and
inequalities that in the context.</p>
<p>We can show that the first example in the last snippet
cannot be proved if we replace <code class="docutils literal notranslate"><span class="pre">&lt;</span></code> by <code class="docutils literal notranslate"><span class="pre">&#8804;</span></code>.
Notice that we can prove the negation of a universally
quantified statement by giving a counterexample.
Complete the proof.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=import%20data.real.basic%0A%0A--%20BEGIN%0Aexample%20%3A%0A%20%20%C2%AC%20%E2%88%80%20%7Bf%20%3A%20%E2%84%9D%20%E2%86%92%20%E2%84%9D%7D%2C%20monotone%20f%20%E2%86%92%20%E2%88%80%20%7Ba%20b%7D%2C%20f%20a%20%E2%89%A4%20f%20b%20%E2%86%92%20a%20%E2%89%A4%20b%20%3A%3D%0Abegin%0A%20%20intro%20h%2C%0A%20%20let%20f%20%3A%3D%20%CE%BB%20x%20%3A%20%E2%84%9D%2C%20(0%20%3A%20%E2%84%9D)%2C%0A%20%20have%20monof%20%3A%20monotone%20f%2C%0A%20%20%7B%20sorry%20%7D%2C%0A%20%20have%20h'%20%3A%20f%201%20%E2%89%A4%20f%200%2C%0A%20%20%20%20from%20le_refl%20_%2C%0A%20%20sorry%0Aend%0A--%20END" target="_blank" tryitfile="../examples/logic/unnamed_1125.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span class="kd">example</span> <span class="o">:</span>
  <span class="bp">&#172;</span> <span class="bp">&#8704;</span> <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">&#8477;</span> <span class="bp">&#8594;</span> <span class="n">&#8477;</span><span class="o">},</span> <span class="n">monotone</span> <span class="n">f</span> <span class="bp">&#8594;</span> <span class="bp">&#8704;</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span><span class="o">},</span> <span class="n">f</span> <span class="n">a</span> <span class="bp">&#8804;</span> <span class="n">f</span> <span class="n">b</span> <span class="bp">&#8594;</span> <span class="n">a</span> <span class="bp">&#8804;</span> <span class="n">b</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">intro</span> <span class="n">h</span><span class="o">,</span>
  <span class="k">let</span> <span class="n">f</span> <span class="o">:=</span> <span class="bp">&#955;</span> <span class="n">x</span> <span class="o">:</span> <span class="n">&#8477;</span><span class="o">,</span> <span class="o">(</span><span class="mi">0</span> <span class="o">:</span> <span class="n">&#8477;</span><span class="o">),</span>
  <span class="k">have</span> <span class="n">monof</span> <span class="o">:</span> <span class="n">monotone</span> <span class="n">f</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">sorry</span> <span class="o">},</span>
  <span class="k">have</span> <span class="n">h&#39;</span> <span class="o">:</span> <span class="n">f</span> <span class="mi">1</span> <span class="bp">&#8804;</span> <span class="n">f</span> <span class="mi">0</span><span class="o">,</span>
    <span class="k">from</span> <span class="n">le_refl</span> <span class="n">_</span><span class="o">,</span>
  <span class="n">sorry</span>
<span class="kd">end</span>
</pre></div>
</div>
</div><p>This example introduces the <code class="docutils literal notranslate"><span class="pre">let</span></code> tactic,
which adds a <em>local definition</em> to the context.
If you put the cursor after the <code class="docutils literal notranslate"><span class="pre">let</span></code> command,
in the goal window you will see that the definition
<code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">:</span> <span class="pre">&#8477;</span> <span class="pre">&#8594;</span> <span class="pre">&#8477;</span> <span class="pre">:=</span> <span class="pre">&#955;</span> <span class="pre">(x</span> <span class="pre">:</span> <span class="pre">&#8477;),</span> <span class="pre">0</span></code> has been added to the context.
Lean will unfold the definition of <code class="docutils literal notranslate"><span class="pre">f</span></code> when it has to.
In particular, when we prove <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">1</span> <span class="pre">&#8804;</span> <span class="pre">f</span> <span class="pre">0</span></code> with <code class="docutils literal notranslate"><span class="pre">le_refl</span></code>,
Lean reduces <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">1</span></code> and <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">0</span></code> to <code class="docutils literal notranslate"><span class="pre">0</span></code>.</p>
<p>Use <code class="docutils literal notranslate"><span class="pre">le_of_not_gt</span></code> to prove the following:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=import%20data.real.basic%0A%0A--%20BEGIN%0Aexample%20(x%20%3A%20%E2%84%9D)%20(h%20%3A%20%E2%88%80%20%CE%B5%20%3E%200%2C%20x%20%E2%89%A4%20%CE%B5)%20%3A%20x%20%E2%89%A4%200%20%3A%3D%0Asorry%0A--%20END" target="_blank" tryitfile="../examples/logic/unnamed_1154.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span class="kd">example</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">&#8477;</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">&#8704;</span> <span class="n">&#949;</span> <span class="bp">&gt;</span> <span class="mi">0</span><span class="o">,</span> <span class="n">x</span> <span class="bp">&#8804;</span> <span class="n">&#949;</span><span class="o">)</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">&#8804;</span> <span class="mi">0</span> <span class="o">:=</span>
<span class="n">sorry</span>
</pre></div>
</div>
</div><p>Implicit in many of the proofs we have just done
is the fact that if <code class="docutils literal notranslate"><span class="pre">P</span></code> is any property,
saying that there is nothing with property <code class="docutils literal notranslate"><span class="pre">P</span></code>
is the same as saying that everything fails to have
property <code class="docutils literal notranslate"><span class="pre">P</span></code>,
and saying that not everything has property <code class="docutils literal notranslate"><span class="pre">P</span></code>
is equivalent to saying that something fails to have property <code class="docutils literal notranslate"><span class="pre">P</span></code>.
In other words, all four of the following implications
are valid:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=variables%20%7B%CE%B1%20%3A%20Type*%7D%20(P%20%3A%20%CE%B1%20%E2%86%92%20Prop)%0A%0Aexample%20(h%20%3A%20%C2%AC%20%E2%88%83%20x%2C%20P%20x)%20%3A%20%E2%88%80%20x%2C%20%C2%AC%20P%20x%20%3A%3D%0Asorry%0A%0Aexample%20(h%20%3A%20%E2%88%80%20x%2C%20%C2%AC%20P%20x)%20%3A%20%C2%AC%20%E2%88%83%20x%2C%20P%20x%20%3A%3D%0Asorry%0A%0Aexample%20(h%20%3A%20%C2%AC%20%E2%88%80%20x%2C%20P%20x)%20%3A%20%E2%88%83%20x%2C%20%C2%AC%20P%20x%20%3A%3D%0Asorry%0A%0Aexample%20(h%20%3A%20%E2%88%83%20x%2C%20%C2%AC%20P%20x)%20%3A%20%C2%AC%20%E2%88%80%20x%2C%20P%20x%20%3A%3D%0Asorry" target="_blank" tryitfile="../examples/logic/unnamed_1173.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span class="kd">variables</span> <span class="o">{</span><span class="n">&#945;</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="n">&#945;</span> <span class="bp">&#8594;</span> <span class="kt">Prop</span><span class="o">)</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">&#172;</span> <span class="bp">&#8707;</span> <span class="n">x</span><span class="o">,</span> <span class="n">P</span> <span class="n">x</span><span class="o">)</span> <span class="o">:</span> <span class="bp">&#8704;</span> <span class="n">x</span><span class="o">,</span> <span class="bp">&#172;</span> <span class="n">P</span> <span class="n">x</span> <span class="o">:=</span>
<span class="n">sorry</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">&#8704;</span> <span class="n">x</span><span class="o">,</span> <span class="bp">&#172;</span> <span class="n">P</span> <span class="n">x</span><span class="o">)</span> <span class="o">:</span> <span class="bp">&#172;</span> <span class="bp">&#8707;</span> <span class="n">x</span><span class="o">,</span> <span class="n">P</span> <span class="n">x</span> <span class="o">:=</span>
<span class="n">sorry</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">&#172;</span> <span class="bp">&#8704;</span> <span class="n">x</span><span class="o">,</span> <span class="n">P</span> <span class="n">x</span><span class="o">)</span> <span class="o">:</span> <span class="bp">&#8707;</span> <span class="n">x</span><span class="o">,</span> <span class="bp">&#172;</span> <span class="n">P</span> <span class="n">x</span> <span class="o">:=</span>
<span class="n">sorry</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">&#8707;</span> <span class="n">x</span><span class="o">,</span> <span class="bp">&#172;</span> <span class="n">P</span> <span class="n">x</span><span class="o">)</span> <span class="o">:</span> <span class="bp">&#172;</span> <span class="bp">&#8704;</span> <span class="n">x</span><span class="o">,</span> <span class="n">P</span> <span class="n">x</span> <span class="o">:=</span>
<span class="n">sorry</span>
</pre></div>
</div>
</div><p>The first, second, and fourth are straightforward to
prove using the methods you have already seen.
We encourage you to try it.
The third is more difficult, however,
because it concludes that an object exists
from the fact that its nonexistence is contradictory.
This is an instance of <em>classical</em> mathematical reasoning,
and, in general, you have to declare your intention
of using such reasoning by adding the command
<code class="docutils literal notranslate"><span class="pre">open_locale</span> <span class="pre">classical</span></code> to your file.
(Due to an annoying quirk of Lean,
this cannot appear right after the <code class="docutils literal notranslate"><span class="pre">import</span></code>
lines in your file,
but it can appear later on.)
With that command, we can use proof by contradiction
to prove the third implication as follows.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=import%20tactic%0A%0Avariables%20%7B%CE%B1%20%3A%20Type*%7D%20(P%20%3A%20%CE%B1%20%E2%86%92%20Prop)%0A%0Aopen_locale%20classical%0A%0Aexample%20(h%20%3A%20%C2%AC%20%E2%88%80%20x%2C%20P%20x)%20%3A%20%E2%88%83%20x%2C%20%C2%AC%20P%20x%20%3A%3D%0Abegin%0A%20%20by_contradiction%20h'%2C%0A%20%20apply%20h%2C%0A%20%20intro%20x%2C%0A%20%20show%20P%20x%2C%0A%20%20by_contradiction%20h''%2C%0A%20%20exact%20h'%20%E2%9F%A8x%2C%20h''%E2%9F%A9%0Aend" target="_blank" tryitfile="../examples/logic/unnamed_1206.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span class="kn">import</span> <span class="n">tactic</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">&#945;</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="n">&#945;</span> <span class="bp">&#8594;</span> <span class="kt">Prop</span><span class="o">)</span>

<span class="n">open_locale</span> <span class="n">classical</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">&#172;</span> <span class="bp">&#8704;</span> <span class="n">x</span><span class="o">,</span> <span class="n">P</span> <span class="n">x</span><span class="o">)</span> <span class="o">:</span> <span class="bp">&#8707;</span> <span class="n">x</span><span class="o">,</span> <span class="bp">&#172;</span> <span class="n">P</span> <span class="n">x</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">by_contradiction</span> <span class="n">h&#39;</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">intro</span> <span class="n">x</span><span class="o">,</span>
  <span class="k">show</span> <span class="n">P</span> <span class="n">x</span><span class="o">,</span>
  <span class="n">by_contradiction</span> <span class="n">h&#39;&#39;</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">h&#39;</span> <span class="o">&#10216;</span><span class="n">x</span><span class="o">,</span> <span class="n">h&#39;&#39;</span><span class="o">&#10217;</span>
<span class="kd">end</span>
</pre></div>
</div>
</div><p>Make sure you understand how this works.
The <code class="docutils literal notranslate"><span class="pre">by_contradiction</span></code> tactic allows us to
prove a goal <code class="docutils literal notranslate"><span class="pre">Q</span></code> by assuming <code class="docutils literal notranslate"><span class="pre">&#172;</span> <span class="pre">Q</span></code>
and deriving a contradiction.
In fact, it is equivalent to using the
equivalence <code class="docutils literal notranslate"><span class="pre">not_not</span> <span class="pre">:</span> <span class="pre">&#172;</span> <span class="pre">&#172;</span> <span class="pre">Q</span> <span class="pre">&#8596;</span> <span class="pre">Q</span></code>.
Confirm that you can prove the forward direction
of this equivalence using <code class="docutils literal notranslate"><span class="pre">by_contradiction</span></code>,
while the reverse direction follows from the
ordinary rules for negation.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=import%20tactic%0A%0Aopen_locale%20classical%0A%0Avariable%20(Q%20%3A%20Prop)%0A%0A--%20BEGIN%0Aexample%20(h%20%3A%20%C2%AC%20%C2%AC%20Q)%20%3A%20Q%20%3A%3D%0Asorry%0A%0Aexample%20(h%20%3A%20Q)%20%3A%20%C2%AC%20%C2%AC%20Q%20%3A%3D%0Asorry%0A--%20END" target="_blank" tryitfile="../examples/logic/unnamed_1235.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span class="kd">example</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">&#172;</span> <span class="bp">&#172;</span> <span class="n">Q</span><span class="o">)</span> <span class="o">:</span> <span class="n">Q</span> <span class="o">:=</span>
<span class="n">sorry</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">Q</span><span class="o">)</span> <span class="o">:</span> <span class="bp">&#172;</span> <span class="bp">&#172;</span> <span class="n">Q</span> <span class="o">:=</span>
<span class="n">sorry</span>
</pre></div>
</div>
</div><p>Use proof by contradiction to establish the following,
which is the converse of one of the implications we proved above.
(Hint: use <code class="docutils literal notranslate"><span class="pre">intro</span></code> first.)</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=import%20data.real.basic%0A%0Adef%20fn_ub%20(f%20%3A%20%E2%84%9D%20%E2%86%92%20%E2%84%9D)%20(a%20%3A%20%E2%84%9D)%20%3A%20Prop%20%3A%3D%20%E2%88%80%20x%2C%20f%20x%20%E2%89%A4%20a%0Adef%20fn_has_ub%20(f%20%3A%20%E2%84%9D%20%E2%86%92%20%E2%84%9D)%20%3A%3D%20%E2%88%83%20a%2C%20fn_ub%20f%20a%0A%0Aopen_locale%20classical%0A%0Avariable%20(f%20%3A%20%E2%84%9D%20%E2%86%92%20%E2%84%9D)%0A%0A--%20BEGIN%0Aexample%20(h%20%3A%20%C2%AC%20fn_has_ub%20f)%20%3A%20%E2%88%80%20a%2C%20%E2%88%83%20x%2C%20f%20x%20%3E%20a%20%3A%3D%0Asorry%0A--%20END" target="_blank" tryitfile="../examples/logic/unnamed_1255.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span class="kd">example</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">&#172;</span> <span class="n">fn_has_ub</span> <span class="n">f</span><span class="o">)</span> <span class="o">:</span> <span class="bp">&#8704;</span> <span class="n">a</span><span class="o">,</span> <span class="bp">&#8707;</span> <span class="n">x</span><span class="o">,</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">&gt;</span> <span class="n">a</span> <span class="o">:=</span>
<span class="n">sorry</span>
</pre></div>
</div>
</div><p>It is often tedious to work with compound statements with
a negation in front,
and it is a common mathematical pattern to replace such
statements with equivalent forms in which the negation
has been pushed inward.
To facilitate this, mathlib offers a <code class="docutils literal notranslate"><span class="pre">push_neg</span></code> tactic,
which restates the goal in this way.
The command <code class="docutils literal notranslate"><span class="pre">push_neg</span> <span class="pre">h</span></code> restates the hypothesis <code class="docutils literal notranslate"><span class="pre">h</span></code>.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=import%20data.real.basic%0A%0Adef%20fn_ub%20(f%20%3A%20%E2%84%9D%20%E2%86%92%20%E2%84%9D)%20(a%20%3A%20%E2%84%9D)%20%3A%20Prop%20%3A%3D%20%E2%88%80%20x%2C%20f%20x%20%E2%89%A4%20a%0Adef%20fn_has_ub%20(f%20%3A%20%E2%84%9D%20%E2%86%92%20%E2%84%9D)%20%3A%3D%20%E2%88%83%20a%2C%20fn_ub%20f%20a%0A%0Aopen_locale%20classical%0A%0Avariable%20(f%20%3A%20%E2%84%9D%20%E2%86%92%20%E2%84%9D)%0A%0A--%20BEGIN%0Aexample%20(h%20%3A%20%C2%AC%20%E2%88%80%20a%2C%20%E2%88%83%20x%2C%20f%20x%20%3E%20a)%20%3A%20fn_has_ub%20f%20%3A%3D%0Abegin%0A%20%20push_neg%20at%20h%2C%0A%20%20exact%20h%0Aend%0A%0Aexample%20(h%20%3A%20%C2%AC%20fn_has_ub%20f)%20%3A%20%E2%88%80%20a%2C%20%E2%88%83%20x%2C%20f%20x%20%3E%20a%20%3A%3D%0Abegin%0A%20%20simp%20only%20%5Bfn_has_ub%2C%20fn_ub%5D%20at%20h%2C%0A%20%20push_neg%20at%20h%2C%0A%20%20exact%20h%0Aend%0A--%20END" target="_blank" tryitfile="../examples/logic/unnamed_1280.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span class="kd">example</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">&#172;</span> <span class="bp">&#8704;</span> <span class="n">a</span><span class="o">,</span> <span class="bp">&#8707;</span> <span class="n">x</span><span class="o">,</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">&gt;</span> <span class="n">a</span><span class="o">)</span> <span class="o">:</span> <span class="n">fn_has_ub</span> <span class="n">f</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">push_neg</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">h</span>
<span class="kd">end</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">&#172;</span> <span class="n">fn_has_ub</span> <span class="n">f</span><span class="o">)</span> <span class="o">:</span> <span class="bp">&#8704;</span> <span class="n">a</span><span class="o">,</span> <span class="bp">&#8707;</span> <span class="n">x</span><span class="o">,</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">&gt;</span> <span class="n">a</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">fn_has_ub</span><span class="o">,</span> <span class="n">fn_ub</span><span class="o">]</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">push_neg</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">h</span>
<span class="kd">end</span>
</pre></div>
</div>
</div><p>In the second example, we use Lean&#8217;s simplifier to
expand the definitions of <code class="docutils literal notranslate"><span class="pre">fn_has_ub</span></code> and <code class="docutils literal notranslate"><span class="pre">fn_ub</span></code>.
(We need to use <code class="docutils literal notranslate"><span class="pre">simp</span></code> rather than <code class="docutils literal notranslate"><span class="pre">rw</span></code>
to expand <code class="docutils literal notranslate"><span class="pre">fn_ub</span></code>,
because it appears in the scope of a quantifier.)
You can verify that in the examples above
with <code class="docutils literal notranslate"><span class="pre">&#172;</span> <span class="pre">&#8707;</span> <span class="pre">x,</span> <span class="pre">P</span> <span class="pre">x</span></code> and <code class="docutils literal notranslate"><span class="pre">&#172;</span> <span class="pre">&#8704;</span> <span class="pre">x,</span> <span class="pre">P</span> <span class="pre">x</span></code>,
the <code class="docutils literal notranslate"><span class="pre">push_neg</span></code> tactic does the expected thing.
Without even knowing how to use the conjunction
symbol,
you should be able to use <code class="docutils literal notranslate"><span class="pre">push_neg</span></code>
to prove the following:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=import%20data.real.basic%0A%0Adef%20fn_ub%20(f%20%3A%20%E2%84%9D%20%E2%86%92%20%E2%84%9D)%20(a%20%3A%20%E2%84%9D)%20%3A%20Prop%20%3A%3D%20%E2%88%80%20x%2C%20f%20x%20%E2%89%A4%20a%0Adef%20fn_has_ub%20(f%20%3A%20%E2%84%9D%20%E2%86%92%20%E2%84%9D)%20%3A%3D%20%E2%88%83%20a%2C%20fn_ub%20f%20a%0A%0Aopen_locale%20classical%0A%0Avariable%20(f%20%3A%20%E2%84%9D%20%E2%86%92%20%E2%84%9D)%0A%0A--%20BEGIN%0Aexample%20(h%20%3A%20%C2%AC%20monotone%20f)%20%3A%20%E2%88%83%20x%20y%2C%20x%20%E2%89%A4%20y%20%E2%88%A7%20f%20y%20%3C%20f%20x%20%3A%3D%0Asorry%0A--%20END" target="_blank" tryitfile="../examples/logic/unnamed_1319.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span class="kd">example</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">&#172;</span> <span class="n">monotone</span> <span class="n">f</span><span class="o">)</span> <span class="o">:</span> <span class="bp">&#8707;</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="n">x</span> <span class="bp">&#8804;</span> <span class="n">y</span> <span class="bp">&#8743;</span> <span class="n">f</span> <span class="n">y</span> <span class="bp">&lt;</span> <span class="n">f</span> <span class="n">x</span> <span class="o">:=</span>
<span class="n">sorry</span>
</pre></div>
</div>
</div><p>Mathlib also has a tactic, <code class="docutils literal notranslate"><span class="pre">contrapose</span></code>,
which transforms a goal <code class="docutils literal notranslate"><span class="pre">A</span> <span class="pre">&#8594;</span> <span class="pre">B</span></code> to <code class="docutils literal notranslate"><span class="pre">&#172;</span> <span class="pre">B</span> <span class="pre">&#8594;</span> <span class="pre">&#172;</span> <span class="pre">A</span></code>.
Similarly, given a goal of proving <code class="docutils literal notranslate"><span class="pre">B</span></code> from
hypothesis <code class="docutils literal notranslate"><span class="pre">h</span> <span class="pre">:</span> <span class="pre">A</span></code>,
<code class="docutils literal notranslate"><span class="pre">contrapose</span> <span class="pre">h</span></code> leaves you with a goal of proving
<code class="docutils literal notranslate"><span class="pre">&#172;</span> <span class="pre">A</span></code> from hypothesis <code class="docutils literal notranslate"><span class="pre">&#172;</span> <span class="pre">B</span></code>.
Using <code class="docutils literal notranslate"><span class="pre">contrapose!</span></code> instead of <code class="docutils literal notranslate"><span class="pre">contrapose</span></code>
applies <code class="docutils literal notranslate"><span class="pre">push_neg</span></code> to the goal and the relevant
hypothesis as well.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=import%20data.real.basic%0A%0Adef%20fn_ub%20(f%20%3A%20%E2%84%9D%20%E2%86%92%20%E2%84%9D)%20(a%20%3A%20%E2%84%9D)%20%3A%20Prop%20%3A%3D%20%E2%88%80%20x%2C%20f%20x%20%E2%89%A4%20a%0Adef%20fn_has_ub%20(f%20%3A%20%E2%84%9D%20%E2%86%92%20%E2%84%9D)%20%3A%3D%20%E2%88%83%20a%2C%20fn_ub%20f%20a%0A%0Aopen_locale%20classical%0A%0Avariable%20(f%20%3A%20%E2%84%9D%20%E2%86%92%20%E2%84%9D)%0A%0A--%20BEGIN%0Aexample%20(h%20%3A%20%C2%AC%20fn_has_ub%20f)%20%3A%20%E2%88%80%20a%2C%20%E2%88%83%20x%2C%20f%20x%20%3E%20a%20%3A%3D%0Abegin%0A%20%20contrapose!%20h%2C%0A%20%20exact%20h%0Aend%0A%0Aexample%20(x%20%3A%20%E2%84%9D)%20(h%20%3A%20%E2%88%80%20%CE%B5%20%3E%200%2C%20x%20%E2%89%A4%20%CE%B5)%20%3A%20x%20%E2%89%A4%200%20%3A%3D%0Abegin%0A%20%20contrapose!%20h%2C%0A%20%20use%20x%20%2F%202%2C%0A%20%20split%3B%20linarith%0Aend%0A--%20END" target="_blank" tryitfile="../examples/logic/unnamed_1345.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span class="kd">example</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">&#172;</span> <span class="n">fn_has_ub</span> <span class="n">f</span><span class="o">)</span> <span class="o">:</span> <span class="bp">&#8704;</span> <span class="n">a</span><span class="o">,</span> <span class="bp">&#8707;</span> <span class="n">x</span><span class="o">,</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">&gt;</span> <span class="n">a</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">contrapose</span><span class="bp">!</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">h</span>
<span class="kd">end</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">&#8477;</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">&#8704;</span> <span class="n">&#949;</span> <span class="bp">&gt;</span> <span class="mi">0</span><span class="o">,</span> <span class="n">x</span> <span class="bp">&#8804;</span> <span class="n">&#949;</span><span class="o">)</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">&#8804;</span> <span class="mi">0</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">contrapose</span><span class="bp">!</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">use</span> <span class="n">x</span> <span class="bp">/</span> <span class="mi">2</span><span class="o">,</span>
  <span class="n">split</span><span class="bp">;</span> <span class="n">linarith</span>
<span class="kd">end</span>
</pre></div>
</div>
</div><p>We have not yet explained the <code class="docutils literal notranslate"><span class="pre">split</span></code> command
or the use of the semicolon after it,
but we will do that in the next section.</p>
<p>We close this section with
the principle of <em>ex falso</em>,
which says that anything follows from a contradiction.
In Lean, this is represented by <code class="docutils literal notranslate"><span class="pre">false.elim</span></code>,
which establishes <code class="docutils literal notranslate"><span class="pre">false</span> <span class="pre">&#8594;</span> <span class="pre">P</span></code> for any proposition <code class="docutils literal notranslate"><span class="pre">P</span></code>.
This may seem like a strange principle,
but it comes up fairly often.
We often prove a theorem by splitting on cases,
and sometimes we can show that one of
the cases is contradictory.
In that case, we need to assert that the contradiction
establishes the goal so we can move on to the next one.
(We will see instances of reasoning by cases in
<a class="reference internal" href="#disjunction"><span class="std std-numref">Section 3.5</span></a>.)</p>
<p>Lean provides a number of ways of closing
a goal once a contradiction has been reached.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=variable%20a%20%3A%20%E2%84%95%0A%0A--%20BEGIN%0Aexample%20(h%20%3A%200%20%3C%200)%20%3A%20a%20%3E%2037%20%3A%3D%0Abegin%0A%20%20exfalso%2C%0A%20%20apply%20lt_irrefl%200%20h%0Aend%0A%0Aexample%20(h%20%3A%200%20%3C%200)%20%3A%20a%20%3E%2037%20%3A%3D%0Aabsurd%20h%20(lt_irrefl%200)%0A%0Aexample%20(h%20%3A%200%20%3C%200)%20%3A%20a%20%3E%2037%20%3A%3D%0Abegin%0A%20%20have%20h'%20%3A%20%C2%AC%200%20%3C%200%2C%0A%20%20%20%20from%20lt_irrefl%200%2C%0A%20%20contradiction%0Aend%0A--%20END" target="_blank" tryitfile="../examples/logic/unnamed_1396.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span class="kd">example</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">&gt;</span> <span class="mi">37</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">exfalso</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">lt_irrefl</span> <span class="mi">0</span> <span class="n">h</span>
<span class="kd">end</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">&gt;</span> <span class="mi">37</span> <span class="o">:=</span>
<span class="n">absurd</span> <span class="n">h</span> <span class="o">(</span><span class="n">lt_irrefl</span> <span class="mi">0</span><span class="o">)</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">&gt;</span> <span class="mi">37</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="k">have</span> <span class="n">h&#39;</span> <span class="o">:</span> <span class="bp">&#172;</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="mi">0</span><span class="o">,</span>
    <span class="k">from</span> <span class="n">lt_irrefl</span> <span class="mi">0</span><span class="o">,</span>
  <span class="n">contradiction</span>
<span class="kd">end</span>
</pre></div>
</div>
</div><p>The <code class="docutils literal notranslate"><span class="pre">exfalso</span></code> tactic replaces the current goal with
the goal of proving <code class="docutils literal notranslate"><span class="pre">false</span></code>.
Given <code class="docutils literal notranslate"><span class="pre">h</span> <span class="pre">:</span> <span class="pre">P</span></code> and <code class="docutils literal notranslate"><span class="pre">h'</span> <span class="pre">:</span> <span class="pre">&#172;</span> <span class="pre">P</span></code>,
the term <code class="docutils literal notranslate"><span class="pre">absurd</span> <span class="pre">h</span> <span class="pre">h'</span></code> establishes any proposition.
Finally, the <code class="docutils literal notranslate"><span class="pre">contradiction</span></code> tactic tries to close a goal
by finding a contradiction in the hypotheses,
such as a pair of the form <code class="docutils literal notranslate"><span class="pre">h</span> <span class="pre">:</span> <span class="pre">P</span></code> and <code class="docutils literal notranslate"><span class="pre">h'</span> <span class="pre">:</span> <span class="pre">&#172;</span> <span class="pre">P</span></code>.
Of course, in this example, <code class="docutils literal notranslate"><span class="pre">linarith</span></code> also works.</p>
</div>
<div class="section" id="conjunction-and-bi-implication">
<span id="conjunction-and-biimplication"></span><h2><span class="section-number">3.4. </span>Conjunction and Bi-implication<a class="headerlink" href="#conjunction-and-bi-implication" title="Permalink to this headline">&#182;</a></h2>
<p>You have already seen that the conjunction symbol, <code class="docutils literal notranslate"><span class="pre">&#8743;</span></code>,
is used to express &#8220;and.&#8221;
The <code class="docutils literal notranslate"><span class="pre">split</span></code> tactic allows you to prove a statement of
the form <code class="docutils literal notranslate"><span class="pre">A</span> <span class="pre">&#8743;</span> <span class="pre">B</span></code>
by proving <code class="docutils literal notranslate"><span class="pre">A</span></code> and then proving <code class="docutils literal notranslate"><span class="pre">B</span></code>.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=import%20data.real.basic%0A%0A--%20BEGIN%0Aexample%20%7Bx%20y%20%3A%20%E2%84%9D%7D%20(h%E2%82%80%20%3A%20x%20%E2%89%A4%20y)%20(h%E2%82%81%20%3A%20%C2%AC%20y%20%E2%89%A4%20x)%20%3A%20x%20%E2%89%A4%20y%20%E2%88%A7%20x%20%E2%89%A0%20y%20%3A%3D%0Abegin%0A%20%20split%2C%0A%20%20%7B%20assumption%20%7D%2C%0A%20%20intro%20h%2C%0A%20%20apply%20h%E2%82%81%2C%0A%20%20rw%20h%0Aend%0A--%20END" target="_blank" tryitfile="../examples/logic/unnamed_1439.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span class="kd">example</span> <span class="o">{</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">&#8477;</span><span class="o">}</span> <span class="o">(</span><span class="n">h&#8320;</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">&#8804;</span> <span class="n">y</span><span class="o">)</span> <span class="o">(</span><span class="n">h&#8321;</span> <span class="o">:</span> <span class="bp">&#172;</span> <span class="n">y</span> <span class="bp">&#8804;</span> <span class="n">x</span><span class="o">)</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">&#8804;</span> <span class="n">y</span> <span class="bp">&#8743;</span> <span class="n">x</span> <span class="bp">&#8800;</span> <span class="n">y</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">split</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">assumption</span> <span class="o">},</span>
  <span class="n">intro</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">h&#8321;</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">h</span>
<span class="kd">end</span>
</pre></div>
</div>
</div><p>In this example, the <code class="docutils literal notranslate"><span class="pre">assumption</span></code> tactic
tells Lean to find an assumption that will solve the goal.
Notice that the final <code class="docutils literal notranslate"><span class="pre">rw</span></code> finishes the goal by
applying the reflexivity of <code class="docutils literal notranslate"><span class="pre">&#8804;</span></code>.
The following are alternative ways of carrying out
the previous examples using the anonymous constructor
angle brackets.
The first is a slick proof-term version of the
previous proof,
which drops into tactic mode at the keyword <code class="docutils literal notranslate"><span class="pre">by</span></code>.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=import%20data.real.basic%0A%0A--%20BEGIN%0Aexample%20%7Bx%20y%20%3A%20%E2%84%9D%7D%20(h%E2%82%80%20%3A%20x%20%E2%89%A4%20y)%20(h%E2%82%81%20%3A%20%C2%AC%20y%20%E2%89%A4%20x)%20%3A%20x%20%E2%89%A4%20y%20%E2%88%A7%20x%20%E2%89%A0%20y%20%3A%3D%0A%E2%9F%A8h%E2%82%80%2C%20%CE%BB%20h%2C%20h%E2%82%81%20(by%20rw%20h)%E2%9F%A9%0A%0Aexample%20%7Bx%20y%20%3A%20%E2%84%9D%7D%20(h%E2%82%80%20%3A%20x%20%E2%89%A4%20y)%20(h%E2%82%81%20%3A%20%C2%AC%20y%20%E2%89%A4%20x)%20%3A%20x%20%E2%89%A4%20y%20%E2%88%A7%20x%20%E2%89%A0%20y%20%3A%3D%0Abegin%0A%20%20have%20h%20%3A%20x%20%E2%89%A0%20y%2C%0A%20%20%7B%20contrapose!%20h%E2%82%81%2C%0A%20%20%20%20rw%20h%E2%82%81%20%7D%2C%0A%20%20exact%20%E2%9F%A8h%E2%82%80%2C%20h%E2%9F%A9%0Aend%0A--%20END" target="_blank" tryitfile="../examples/logic/unnamed_1465.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span class="kd">example</span> <span class="o">{</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">&#8477;</span><span class="o">}</span> <span class="o">(</span><span class="n">h&#8320;</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">&#8804;</span> <span class="n">y</span><span class="o">)</span> <span class="o">(</span><span class="n">h&#8321;</span> <span class="o">:</span> <span class="bp">&#172;</span> <span class="n">y</span> <span class="bp">&#8804;</span> <span class="n">x</span><span class="o">)</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">&#8804;</span> <span class="n">y</span> <span class="bp">&#8743;</span> <span class="n">x</span> <span class="bp">&#8800;</span> <span class="n">y</span> <span class="o">:=</span>
<span class="o">&#10216;</span><span class="n">h&#8320;</span><span class="o">,</span> <span class="bp">&#955;</span> <span class="n">h</span><span class="o">,</span> <span class="n">h&#8321;</span> <span class="o">(</span><span class="kd">by</span> <span class="n">rw</span> <span class="n">h</span><span class="o">)&#10217;</span>

<span class="kd">example</span> <span class="o">{</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">&#8477;</span><span class="o">}</span> <span class="o">(</span><span class="n">h&#8320;</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">&#8804;</span> <span class="n">y</span><span class="o">)</span> <span class="o">(</span><span class="n">h&#8321;</span> <span class="o">:</span> <span class="bp">&#172;</span> <span class="n">y</span> <span class="bp">&#8804;</span> <span class="n">x</span><span class="o">)</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">&#8804;</span> <span class="n">y</span> <span class="bp">&#8743;</span> <span class="n">x</span> <span class="bp">&#8800;</span> <span class="n">y</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="k">have</span> <span class="n">h</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">&#8800;</span> <span class="n">y</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">contrapose</span><span class="bp">!</span> <span class="n">h&#8321;</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">h&#8321;</span> <span class="o">},</span>
  <span class="n">exact</span> <span class="o">&#10216;</span><span class="n">h&#8320;</span><span class="o">,</span> <span class="n">h</span><span class="o">&#10217;</span>
<span class="kd">end</span>
</pre></div>
</div>
</div><p><em>Using</em> a conjunction instead of proving one involves unpacking the proofs of the
two parts.
You can uses the <code class="docutils literal notranslate"><span class="pre">cases</span></code> tactic for that,
as well as <code class="docutils literal notranslate"><span class="pre">rcases</span></code>, <code class="docutils literal notranslate"><span class="pre">rintros</span></code>, or a pattern-matching lambda,
all in a manner similar to the way they are used with
the existential quantifier.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=import%20data.real.basic%0A%0A--%20BEGIN%0Aexample%20%7Bx%20y%20%3A%20%E2%84%9D%7D%20(h%20%3A%20x%20%E2%89%A4%20y%20%E2%88%A7%20x%20%E2%89%A0%20y)%20%3A%20%C2%AC%20y%20%E2%89%A4%20x%20%3A%3D%0Abegin%0A%20%20cases%20h%20with%20h%E2%82%80%20h%E2%82%81%2C%0A%20%20contrapose!%20h%E2%82%81%2C%0A%20%20exact%20le_antisymm%20h%E2%82%80%20h%E2%82%81%0Aend%0A%0Aexample%20%7Bx%20y%20%3A%20%E2%84%9D%7D%20%3A%20x%20%E2%89%A4%20y%20%E2%88%A7%20x%20%E2%89%A0%20y%20%E2%86%92%20%C2%AC%20y%20%E2%89%A4%20x%20%3A%3D%0Abegin%0A%20%20rintros%20%E2%9F%A8h%E2%82%80%2C%20h%E2%82%81%E2%9F%A9%20h'%2C%0A%20%20exact%20h%E2%82%81%20(le_antisymm%20h%E2%82%80%20h')%0Aend%0A%0Aexample%20%7Bx%20y%20%3A%20%E2%84%9D%7D%20%3A%20x%20%E2%89%A4%20y%20%E2%88%A7%20x%20%E2%89%A0%20y%20%E2%86%92%20%C2%AC%20y%20%E2%89%A4%20x%20%3A%3D%0A%CE%BB%20%E2%9F%A8h%E2%82%80%2C%20h%E2%82%81%E2%9F%A9%20h'%2C%20h%E2%82%81%20(le_antisymm%20h%E2%82%80%20h')%0A--%20END" target="_blank" tryitfile="../examples/logic/unnamed_1489.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span class="kd">example</span> <span class="o">{</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">&#8477;</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">&#8804;</span> <span class="n">y</span> <span class="bp">&#8743;</span> <span class="n">x</span> <span class="bp">&#8800;</span> <span class="n">y</span><span class="o">)</span> <span class="o">:</span> <span class="bp">&#172;</span> <span class="n">y</span> <span class="bp">&#8804;</span> <span class="n">x</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">cases</span> <span class="n">h</span> <span class="k">with</span> <span class="n">h&#8320;</span> <span class="n">h&#8321;</span><span class="o">,</span>
  <span class="n">contrapose</span><span class="bp">!</span> <span class="n">h&#8321;</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">le_antisymm</span> <span class="n">h&#8320;</span> <span class="n">h&#8321;</span>
<span class="kd">end</span>

<span class="kd">example</span> <span class="o">{</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">&#8477;</span><span class="o">}</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">&#8804;</span> <span class="n">y</span> <span class="bp">&#8743;</span> <span class="n">x</span> <span class="bp">&#8800;</span> <span class="n">y</span> <span class="bp">&#8594;</span> <span class="bp">&#172;</span> <span class="n">y</span> <span class="bp">&#8804;</span> <span class="n">x</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rintros</span> <span class="o">&#10216;</span><span class="n">h&#8320;</span><span class="o">,</span> <span class="n">h&#8321;</span><span class="o">&#10217;</span> <span class="n">h&#39;</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">h&#8321;</span> <span class="o">(</span><span class="n">le_antisymm</span> <span class="n">h&#8320;</span> <span class="n">h&#39;</span><span class="o">)</span>
<span class="kd">end</span>

<span class="kd">example</span> <span class="o">{</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">&#8477;</span><span class="o">}</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">&#8804;</span> <span class="n">y</span> <span class="bp">&#8743;</span> <span class="n">x</span> <span class="bp">&#8800;</span> <span class="n">y</span> <span class="bp">&#8594;</span> <span class="bp">&#172;</span> <span class="n">y</span> <span class="bp">&#8804;</span> <span class="n">x</span> <span class="o">:=</span>
<span class="bp">&#955;</span> <span class="o">&#10216;</span><span class="n">h&#8320;</span><span class="o">,</span> <span class="n">h&#8321;</span><span class="o">&#10217;</span> <span class="n">h&#39;</span><span class="o">,</span> <span class="n">h&#8321;</span> <span class="o">(</span><span class="n">le_antisymm</span> <span class="n">h&#8320;</span> <span class="n">h&#39;</span><span class="o">)</span>
</pre></div>
</div>
</div><p>In contrast to using an existential quantifier,
you can also extract proofs of the two components
of a hypothesis <code class="docutils literal notranslate"><span class="pre">h</span> <span class="pre">:</span> <span class="pre">A</span> <span class="pre">&#8743;</span> <span class="pre">B</span></code>
by writing <code class="docutils literal notranslate"><span class="pre">h.left</span></code> and <code class="docutils literal notranslate"><span class="pre">h.right</span></code>,
or, equivalently, <code class="docutils literal notranslate"><span class="pre">h.1</span></code> and <code class="docutils literal notranslate"><span class="pre">h.2</span></code>.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=import%20data.real.basic%0A%0A--%20BEGIN%0Aexample%20%7Bx%20y%20%3A%20%E2%84%9D%7D%20(h%20%3A%20x%20%E2%89%A4%20y%20%E2%88%A7%20x%20%E2%89%A0%20y)%20%3A%20%C2%AC%20y%20%E2%89%A4%20x%20%3A%3D%0Abegin%0A%20%20intro%20h'%2C%0A%20%20apply%20h.right%2C%0A%20%20exact%20le_antisymm%20h.left%20h'%0Aend%0A%0Aexample%20%7Bx%20y%20%3A%20%E2%84%9D%7D%20(h%20%3A%20x%20%E2%89%A4%20y%20%E2%88%A7%20x%20%E2%89%A0%20y)%20%3A%20%C2%AC%20y%20%E2%89%A4%20x%20%3A%3D%0A%CE%BB%20h'%2C%20h.right%20(le_antisymm%20h.left%20h')%0A--%20END" target="_blank" tryitfile="../examples/logic/unnamed_1517.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span class="kd">example</span> <span class="o">{</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">&#8477;</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">&#8804;</span> <span class="n">y</span> <span class="bp">&#8743;</span> <span class="n">x</span> <span class="bp">&#8800;</span> <span class="n">y</span><span class="o">)</span> <span class="o">:</span> <span class="bp">&#172;</span> <span class="n">y</span> <span class="bp">&#8804;</span> <span class="n">x</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">intro</span> <span class="n">h&#39;</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">h.right</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">le_antisymm</span> <span class="n">h.left</span> <span class="n">h&#39;</span>
<span class="kd">end</span>

<span class="kd">example</span> <span class="o">{</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">&#8477;</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">&#8804;</span> <span class="n">y</span> <span class="bp">&#8743;</span> <span class="n">x</span> <span class="bp">&#8800;</span> <span class="n">y</span><span class="o">)</span> <span class="o">:</span> <span class="bp">&#172;</span> <span class="n">y</span> <span class="bp">&#8804;</span> <span class="n">x</span> <span class="o">:=</span>
<span class="bp">&#955;</span> <span class="n">h&#39;</span><span class="o">,</span> <span class="n">h.right</span> <span class="o">(</span><span class="n">le_antisymm</span> <span class="n">h.left</span> <span class="n">h&#39;</span><span class="o">)</span>
</pre></div>
</div>
</div><p>Try using these techniques to come up with various ways of proving of the following:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=import%20data.nat.gcd%0A%0Aopen%20nat%0A%0A--%20BEGIN%0Aexample%20%7Bm%20n%20%3A%20%E2%84%95%7D%20(h%20%3A%20m%20%E2%88%A3%20n%20%E2%88%A7%20m%20%E2%89%A0%20n)%20%3A%0A%20%20m%20%E2%88%A3%20n%20%E2%88%A7%20%C2%AC%20n%20%E2%88%A3%20m%20%3A%3D%0Asorry%0A--%20END" target="_blank" tryitfile="../examples/logic/unnamed_1535.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span class="kd">example</span> <span class="o">{</span><span class="n">m</span> <span class="n">n</span> <span class="o">:</span> <span class="n">&#8469;</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">m</span> <span class="bp">&#8739;</span> <span class="n">n</span> <span class="bp">&#8743;</span> <span class="n">m</span> <span class="bp">&#8800;</span> <span class="n">n</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">m</span> <span class="bp">&#8739;</span> <span class="n">n</span> <span class="bp">&#8743;</span> <span class="bp">&#172;</span> <span class="n">n</span> <span class="bp">&#8739;</span> <span class="n">m</span> <span class="o">:=</span>
<span class="n">sorry</span>
</pre></div>
</div>
</div><p>You can nest uses of <code class="docutils literal notranslate"><span class="pre">&#8707;</span></code> and <code class="docutils literal notranslate"><span class="pre">&#8743;</span></code>
with anonymous constructors, <code class="docutils literal notranslate"><span class="pre">rintros</span></code>, and <code class="docutils literal notranslate"><span class="pre">rcases</span></code>.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=import%20data.real.basic%0A%0A--%20BEGIN%0Aexample%20%3A%20%E2%88%83%20x%20%3A%20%E2%84%9D%2C%202%20%3C%20x%20%E2%88%A7%20x%20%3C%204%20%3A%3D%0A%E2%9F%A85%2F2%2C%20by%20norm_num%2C%20by%20norm_num%E2%9F%A9%0A%0Aexample%20(x%20y%20%3A%20%E2%84%9D)%20%3A%20(%E2%88%83%20z%20%3A%20%E2%84%9D%2C%20x%20%3C%20z%20%E2%88%A7%20z%20%3C%20y)%20%E2%86%92%20x%20%3C%20y%20%3A%3D%0Abegin%0A%20%20rintros%20%E2%9F%A8z%2C%20xltz%2C%20zlty%E2%9F%A9%2C%0A%20%20exact%20lt_trans%20xltz%20zlty%0Aend%0A%0Aexample%20(x%20y%20%3A%20%E2%84%9D)%20%3A%20(%E2%88%83%20z%20%3A%20%E2%84%9D%2C%20x%20%3C%20z%20%E2%88%A7%20z%20%3C%20y)%20%E2%86%92%20x%20%3C%20y%20%3A%3D%0A%CE%BB%20%E2%9F%A8z%2C%20xltz%2C%20zlty%E2%9F%A9%2C%20lt_trans%20xltz%20zlty%0A--%20END" target="_blank" tryitfile="../examples/logic/unnamed_1550.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span class="kd">example</span> <span class="o">:</span> <span class="bp">&#8707;</span> <span class="n">x</span> <span class="o">:</span> <span class="n">&#8477;</span><span class="o">,</span> <span class="mi">2</span> <span class="bp">&lt;</span> <span class="n">x</span> <span class="bp">&#8743;</span> <span class="n">x</span> <span class="bp">&lt;</span> <span class="mi">4</span> <span class="o">:=</span>
<span class="o">&#10216;</span><span class="mi">5</span><span class="bp">/</span><span class="mi">2</span><span class="o">,</span> <span class="kd">by</span> <span class="n">norm_num</span><span class="o">,</span> <span class="kd">by</span> <span class="n">norm_num</span><span class="o">&#10217;</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">&#8477;</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="bp">&#8707;</span> <span class="n">z</span> <span class="o">:</span> <span class="n">&#8477;</span><span class="o">,</span> <span class="n">x</span> <span class="bp">&lt;</span> <span class="n">z</span> <span class="bp">&#8743;</span> <span class="n">z</span> <span class="bp">&lt;</span> <span class="n">y</span><span class="o">)</span> <span class="bp">&#8594;</span> <span class="n">x</span> <span class="bp">&lt;</span> <span class="n">y</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rintros</span> <span class="o">&#10216;</span><span class="n">z</span><span class="o">,</span> <span class="n">xltz</span><span class="o">,</span> <span class="n">zlty</span><span class="o">&#10217;,</span>
  <span class="n">exact</span> <span class="n">lt_trans</span> <span class="n">xltz</span> <span class="n">zlty</span>
<span class="kd">end</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">&#8477;</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="bp">&#8707;</span> <span class="n">z</span> <span class="o">:</span> <span class="n">&#8477;</span><span class="o">,</span> <span class="n">x</span> <span class="bp">&lt;</span> <span class="n">z</span> <span class="bp">&#8743;</span> <span class="n">z</span> <span class="bp">&lt;</span> <span class="n">y</span><span class="o">)</span> <span class="bp">&#8594;</span> <span class="n">x</span> <span class="bp">&lt;</span> <span class="n">y</span> <span class="o">:=</span>
<span class="bp">&#955;</span> <span class="o">&#10216;</span><span class="n">z</span><span class="o">,</span> <span class="n">xltz</span><span class="o">,</span> <span class="n">zlty</span><span class="o">&#10217;,</span> <span class="n">lt_trans</span> <span class="n">xltz</span> <span class="n">zlty</span>
</pre></div>
</div>
</div><p>You can also use the <code class="docutils literal notranslate"><span class="pre">use</span></code> tactic:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=import%20data.real.basic%0Aimport%20data.nat.gcd%0A%0Aopen%20nat%0A%0A--%20BEGIN%0Aexample%20%3A%20%E2%88%83%20x%20%3A%20%E2%84%9D%2C%202%20%3C%20x%20%E2%88%A7%20x%20%3C%204%20%3A%3D%0Abegin%0A%20%20use%205%20%2F%202%2C%0A%20%20split%3B%20norm_num%0Aend%0A%0Aexample%20%3A%20%E2%88%83%20m%20n%20%3A%20%E2%84%95%2C%0A%20%204%20%3C%20m%20%E2%88%A7%20m%20%3C%20n%20%E2%88%A7%20n%20%3C%2010%20%E2%88%A7%20prime%20m%20%E2%88%A7%20prime%20n%20%3A%3D%0Abegin%0A%20%20use%20%5B5%2C%207%5D%2C%0A%20%20norm_num%0Aend%0A%0Aexample%20%7Bx%20y%20%3A%20%E2%84%9D%7D%20%3A%20x%20%E2%89%A4%20y%20%E2%88%A7%20x%20%E2%89%A0%20y%20%E2%86%92%20x%20%E2%89%A4%20y%20%E2%88%A7%20%C2%AC%20y%20%E2%89%A4%20x%20%3A%3D%0Abegin%0A%20%20rintros%20%E2%9F%A8h%E2%82%80%2C%20h%E2%82%81%E2%9F%A9%2C%0A%20%20use%20%5Bh%E2%82%80%2C%20%CE%BB%20h'%2C%20h%E2%82%81%20(le_antisymm%20h%E2%82%80%20h')%5D%0Aend%0A--%20END" target="_blank" tryitfile="../examples/logic/unnamed_1570.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span class="kd">example</span> <span class="o">:</span> <span class="bp">&#8707;</span> <span class="n">x</span> <span class="o">:</span> <span class="n">&#8477;</span><span class="o">,</span> <span class="mi">2</span> <span class="bp">&lt;</span> <span class="n">x</span> <span class="bp">&#8743;</span> <span class="n">x</span> <span class="bp">&lt;</span> <span class="mi">4</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">use</span> <span class="mi">5</span> <span class="bp">/</span> <span class="mi">2</span><span class="o">,</span>
  <span class="n">split</span><span class="bp">;</span> <span class="n">norm_num</span>
<span class="kd">end</span>

<span class="kd">example</span> <span class="o">:</span> <span class="bp">&#8707;</span> <span class="n">m</span> <span class="n">n</span> <span class="o">:</span> <span class="n">&#8469;</span><span class="o">,</span>
  <span class="mi">4</span> <span class="bp">&lt;</span> <span class="n">m</span> <span class="bp">&#8743;</span> <span class="n">m</span> <span class="bp">&lt;</span> <span class="n">n</span> <span class="bp">&#8743;</span> <span class="n">n</span> <span class="bp">&lt;</span> <span class="mi">10</span> <span class="bp">&#8743;</span> <span class="n">prime</span> <span class="n">m</span> <span class="bp">&#8743;</span> <span class="n">prime</span> <span class="n">n</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">use</span> <span class="o">[</span><span class="mi">5</span><span class="o">,</span> <span class="mi">7</span><span class="o">],</span>
  <span class="n">norm_num</span>
<span class="kd">end</span>

<span class="kd">example</span> <span class="o">{</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">&#8477;</span><span class="o">}</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">&#8804;</span> <span class="n">y</span> <span class="bp">&#8743;</span> <span class="n">x</span> <span class="bp">&#8800;</span> <span class="n">y</span> <span class="bp">&#8594;</span> <span class="n">x</span> <span class="bp">&#8804;</span> <span class="n">y</span> <span class="bp">&#8743;</span> <span class="bp">&#172;</span> <span class="n">y</span> <span class="bp">&#8804;</span> <span class="n">x</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rintros</span> <span class="o">&#10216;</span><span class="n">h&#8320;</span><span class="o">,</span> <span class="n">h&#8321;</span><span class="o">&#10217;,</span>
  <span class="n">use</span> <span class="o">[</span><span class="n">h&#8320;</span><span class="o">,</span> <span class="bp">&#955;</span> <span class="n">h&#39;</span><span class="o">,</span> <span class="n">h&#8321;</span> <span class="o">(</span><span class="n">le_antisymm</span> <span class="n">h&#8320;</span> <span class="n">h&#39;</span><span class="o">)]</span>
<span class="kd">end</span>
</pre></div>
</div>
</div><p>In the first example, the semicolon after the <code class="docutils literal notranslate"><span class="pre">split</span></code> command tells Lean to use the
<code class="docutils literal notranslate"><span class="pre">norm_num</span></code> tactic on both of the goals that result.</p>
<p>In Lean, <code class="docutils literal notranslate"><span class="pre">A</span> <span class="pre">&#8596;</span> <span class="pre">B</span></code> is <em>not</em> defined to be <code class="docutils literal notranslate"><span class="pre">(A</span> <span class="pre">&#8594;</span> <span class="pre">B)</span> <span class="pre">&#8743;</span> <span class="pre">(B</span> <span class="pre">&#8594;</span> <span class="pre">A)</span></code>,
but it could have been,
and it behaves roughly the same way.
You have already seen that you can write <code class="docutils literal notranslate"><span class="pre">h.mp</span></code> and <code class="docutils literal notranslate"><span class="pre">h.mpr</span></code>
or <code class="docutils literal notranslate"><span class="pre">h.1</span></code> and <code class="docutils literal notranslate"><span class="pre">h.2</span></code> for the two directions of <code class="docutils literal notranslate"><span class="pre">h</span> <span class="pre">:</span> <span class="pre">A</span> <span class="pre">&#8596;</span> <span class="pre">B</span></code>.
You can also use <code class="docutils literal notranslate"><span class="pre">cases</span></code> and friends.
To prove an if-and-only-if statement,
you can uses <code class="docutils literal notranslate"><span class="pre">split</span></code> or angle brackets,
just as you would if you were proving a conjunction.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=import%20data.real.basic%0A%0A--%20BEGIN%0Aexample%20%7Bx%20y%20%3A%20%E2%84%9D%7D%20(h%20%3A%20x%20%E2%89%A4%20y)%20%3A%20%C2%AC%20y%20%E2%89%A4%20x%20%E2%86%94%20x%20%E2%89%A0%20y%20%3A%3D%0Abegin%0A%20%20split%2C%0A%20%20%7B%20contrapose!%2C%0A%20%20%20%20rintro%20rfl%2C%0A%20%20%20%20reflexivity%20%7D%2C%0A%20%20contrapose!%2C%0A%20%20exact%20le_antisymm%20h%0Aend%0A%0Aexample%20%7Bx%20y%20%3A%20%E2%84%9D%7D%20(h%20%3A%20x%20%E2%89%A4%20y)%20%3A%20%C2%AC%20y%20%E2%89%A4%20x%20%E2%86%94%20x%20%E2%89%A0%20y%20%3A%3D%0A%E2%9F%A8%CE%BB%20h%E2%82%80%20h%E2%82%81%2C%20h%E2%82%80%20(by%20rw%20h%E2%82%81)%2C%20%CE%BB%20h%E2%82%80%20h%E2%82%81%2C%20h%E2%82%80%20(le_antisymm%20h%20h%E2%82%81)%E2%9F%A9%0A--%20END" target="_blank" tryitfile="../examples/logic/unnamed_1611.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span class="kd">example</span> <span class="o">{</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">&#8477;</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">&#8804;</span> <span class="n">y</span><span class="o">)</span> <span class="o">:</span> <span class="bp">&#172;</span> <span class="n">y</span> <span class="bp">&#8804;</span> <span class="n">x</span> <span class="bp">&#8596;</span> <span class="n">x</span> <span class="bp">&#8800;</span> <span class="n">y</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">split</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">contrapose</span><span class="bp">!</span><span class="o">,</span>
    <span class="n">rintro</span> <span class="n">rfl</span><span class="o">,</span>
    <span class="n">reflexivity</span> <span class="o">},</span>
  <span class="n">contrapose</span><span class="bp">!</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">le_antisymm</span> <span class="n">h</span>
<span class="kd">end</span>

<span class="kd">example</span> <span class="o">{</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">&#8477;</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">&#8804;</span> <span class="n">y</span><span class="o">)</span> <span class="o">:</span> <span class="bp">&#172;</span> <span class="n">y</span> <span class="bp">&#8804;</span> <span class="n">x</span> <span class="bp">&#8596;</span> <span class="n">x</span> <span class="bp">&#8800;</span> <span class="n">y</span> <span class="o">:=</span>
<span class="o">&#10216;</span><span class="bp">&#955;</span> <span class="n">h&#8320;</span> <span class="n">h&#8321;</span><span class="o">,</span> <span class="n">h&#8320;</span> <span class="o">(</span><span class="kd">by</span> <span class="n">rw</span> <span class="n">h&#8321;</span><span class="o">),</span> <span class="bp">&#955;</span> <span class="n">h&#8320;</span> <span class="n">h&#8321;</span><span class="o">,</span> <span class="n">h&#8320;</span> <span class="o">(</span><span class="n">le_antisymm</span> <span class="n">h</span> <span class="n">h&#8321;</span><span class="o">)&#10217;</span>
</pre></div>
</div>
</div><p>The last proof term is inscrutable. Remember that you can
use underscores while writing an expression like that to
see what Lean expects.</p>
<p>Try out the various techniques and gadgets you have just seen
in order to prove the following:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=import%20data.real.basic%0A%0A--%20BEGIN%0Aexample%20%7Bx%20y%20%3A%20%E2%84%9D%7D%20%3A%20x%20%E2%89%A4%20y%20%E2%88%A7%20%C2%AC%20y%20%E2%89%A4%20x%20%E2%86%94%20x%20%E2%89%A4%20y%20%E2%88%A7%20x%20%E2%89%A0%20y%20%3A%3D%0Asorry%0A--%20END" target="_blank" tryitfile="../examples/logic/unnamed_1637.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span class="kd">example</span> <span class="o">{</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">&#8477;</span><span class="o">}</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">&#8804;</span> <span class="n">y</span> <span class="bp">&#8743;</span> <span class="bp">&#172;</span> <span class="n">y</span> <span class="bp">&#8804;</span> <span class="n">x</span> <span class="bp">&#8596;</span> <span class="n">x</span> <span class="bp">&#8804;</span> <span class="n">y</span> <span class="bp">&#8743;</span> <span class="n">x</span> <span class="bp">&#8800;</span> <span class="n">y</span> <span class="o">:=</span>
<span class="n">sorry</span>
</pre></div>
</div>
</div><p>For a more interesting exercise, show that for any
two real numbers <code class="docutils literal notranslate"><span class="pre">x</span></code> and <code class="docutils literal notranslate"><span class="pre">y</span></code>,
<code class="docutils literal notranslate"><span class="pre">x^2</span> <span class="pre">+</span> <span class="pre">y^2</span> <span class="pre">=</span> <span class="pre">0</span></code> if and only if <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">0</span></code> and <code class="docutils literal notranslate"><span class="pre">y</span> <span class="pre">=</span> <span class="pre">0</span></code>.
We suggest proving an auxiliary lemma using
<code class="docutils literal notranslate"><span class="pre">linarith</span></code>, <code class="docutils literal notranslate"><span class="pre">pow_two_nonneg</span></code>, and <code class="docutils literal notranslate"><span class="pre">pow_eq_zero</span></code>.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=import%20data.real.basic%0A%0A--%20BEGIN%0Atheorem%20aux%20%7Bx%20y%20%3A%20%E2%84%9D%7D%20(h%20%3A%20x%5E2%20%2B%20y%5E2%20%3D%200)%20%3A%20x%20%3D%200%20%3A%3D%0Abegin%0A%20%20have%20h'%20%3A%20x%5E2%20%3D%200%2C%0A%20%20%7B%20sorry%20%7D%2C%0A%20%20exact%20pow_eq_zero%20h'%0Aend%0A%0Aexample%20(x%20y%20%3A%20%E2%84%9D)%20%3A%20x%5E2%20%2B%20y%5E2%20%3D%200%20%E2%86%94%20x%20%3D%200%20%E2%88%A7%20y%20%3D%200%20%3A%3D%0Asorry%0A--%20END" target="_blank" tryitfile="../examples/logic/unnamed_1652.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span class="kd">theorem</span> <span class="n">aux</span> <span class="o">{</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">&#8477;</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">x</span><span class="bp">^</span><span class="mi">2</span> <span class="bp">+</span> <span class="n">y</span><span class="bp">^</span><span class="mi">2</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="k">have</span> <span class="n">h&#39;</span> <span class="o">:</span> <span class="n">x</span><span class="bp">^</span><span class="mi">2</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">sorry</span> <span class="o">},</span>
  <span class="n">exact</span> <span class="n">pow_eq_zero</span> <span class="n">h&#39;</span>
<span class="kd">end</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">&#8477;</span><span class="o">)</span> <span class="o">:</span> <span class="n">x</span><span class="bp">^</span><span class="mi">2</span> <span class="bp">+</span> <span class="n">y</span><span class="bp">^</span><span class="mi">2</span> <span class="bp">=</span> <span class="mi">0</span> <span class="bp">&#8596;</span> <span class="n">x</span> <span class="bp">=</span> <span class="mi">0</span> <span class="bp">&#8743;</span> <span class="n">y</span> <span class="bp">=</span> <span class="mi">0</span> <span class="o">:=</span>
<span class="n">sorry</span>
</pre></div>
</div>
</div><p>In Lean, bi-implication leads a double-life.
You can treat it like a conjunction and use its two
parts separately.
But Lean also knows that it is a reflexive, symmetric,
and transitive relation between propositions,
and you can also use it with <code class="docutils literal notranslate"><span class="pre">calc</span></code> and <code class="docutils literal notranslate"><span class="pre">rw</span></code>.
It is often convenient to rewrite a statement to
an equivalent one.
In the next example, we use <code class="docutils literal notranslate"><span class="pre">abs_lt</span></code> to
replace an expression of the form <code class="docutils literal notranslate"><span class="pre">abs</span> <span class="pre">x</span> <span class="pre">&lt;</span> <span class="pre">y</span></code>
by the equivalent expression <code class="docutils literal notranslate"><span class="pre">-</span> <span class="pre">y</span> <span class="pre">&lt;</span> <span class="pre">x</span> <span class="pre">&#8743;</span> <span class="pre">x</span> <span class="pre">&lt;</span> <span class="pre">y</span></code>,
and in the one after that we use <code class="docutils literal notranslate"><span class="pre">dvd_gcd_iff</span></code>
to replace an expression of the form <code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">&#8739;</span> <span class="pre">gcd</span> <span class="pre">n</span> <span class="pre">k</span></code> by the equivalent expression <code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">&#8739;</span> <span class="pre">n</span> <span class="pre">&#8743;</span> <span class="pre">m</span> <span class="pre">&#8739;</span> <span class="pre">k</span></code>.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=import%20data.real.basic%0Aimport%20data.nat.gcd%0A%0Aopen%20nat%0A%0A--%20BEGIN%0Aexample%20(x%20y%20%3A%20%E2%84%9D)%20%3A%20abs%20(x%20%2B%203)%20%3C%205%20%E2%86%92%20-8%20%3C%20x%20%E2%88%A7%20x%20%3C%202%20%3A%3D%0Abegin%0A%20%20rw%20abs_lt%2C%0A%20%20intro%20h%2C%0A%20%20split%3B%20linarith%0Aend%0A%0Aexample%20%3A%203%20%E2%88%A3%20gcd%206%2015%20%3A%3D%0Abegin%0A%20%20rw%20dvd_gcd_iff%2C%0A%20%20split%3B%20norm_num%0Aend%0A--%20END" target="_blank" tryitfile="../examples/logic/unnamed_1682.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span class="kd">example</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">&#8477;</span><span class="o">)</span> <span class="o">:</span> <span class="n">abs</span> <span class="o">(</span><span class="n">x</span> <span class="bp">+</span> <span class="mi">3</span><span class="o">)</span> <span class="bp">&lt;</span> <span class="mi">5</span> <span class="bp">&#8594;</span> <span class="bp">-</span><span class="mi">8</span> <span class="bp">&lt;</span> <span class="n">x</span> <span class="bp">&#8743;</span> <span class="n">x</span> <span class="bp">&lt;</span> <span class="mi">2</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rw</span> <span class="n">abs_lt</span><span class="o">,</span>
  <span class="n">intro</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">split</span><span class="bp">;</span> <span class="n">linarith</span>
<span class="kd">end</span>

<span class="kd">example</span> <span class="o">:</span> <span class="mi">3</span> <span class="bp">&#8739;</span> <span class="n">gcd</span> <span class="mi">6</span> <span class="mi">15</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rw</span> <span class="n">dvd_gcd_iff</span><span class="o">,</span>
  <span class="n">split</span><span class="bp">;</span> <span class="n">norm_num</span>
<span class="kd">end</span>
</pre></div>
</div>
</div><p>See if you can use <code class="docutils literal notranslate"><span class="pre">rw</span></code> with the theorem below
to provide a short proof that negation is not a
nondecreasing function.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=import%20data.real.basic%0A%0A--%20BEGIN%0Atheorem%20not_monotone_iff%20%7Bf%20%3A%20%E2%84%9D%20%E2%86%92%20%E2%84%9D%7D%3A%0A%20%20%C2%AC%20monotone%20f%20%E2%86%94%20%E2%88%83%20x%20y%2C%20x%20%E2%89%A4%20y%20%E2%88%A7%20f%20x%20%3E%20f%20y%20%3A%3D%0Aby%20%7B%20rw%20%5Bmonotone%5D%2C%20push_neg%20%7D%0A%0Aexample%20%3A%20%C2%AC%20monotone%20(%CE%BB%20x%20%3A%20%E2%84%9D%2C%20-x)%20%3A%3D%0Asorry%0A--%20END" target="_blank" tryitfile="../examples/logic/unnamed_1708.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span class="kd">theorem</span> <span class="n">not_monotone_iff</span> <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">&#8477;</span> <span class="bp">&#8594;</span> <span class="n">&#8477;</span><span class="o">}:</span>
  <span class="bp">&#172;</span> <span class="n">monotone</span> <span class="n">f</span> <span class="bp">&#8596;</span> <span class="bp">&#8707;</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="n">x</span> <span class="bp">&#8804;</span> <span class="n">y</span> <span class="bp">&#8743;</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">&gt;</span> <span class="n">f</span> <span class="n">y</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="n">monotone</span><span class="o">],</span> <span class="n">push_neg</span> <span class="o">}</span>

<span class="kd">example</span> <span class="o">:</span> <span class="bp">&#172;</span> <span class="n">monotone</span> <span class="o">(</span><span class="bp">&#955;</span> <span class="n">x</span> <span class="o">:</span> <span class="n">&#8477;</span><span class="o">,</span> <span class="bp">-</span><span class="n">x</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">sorry</span>
</pre></div>
</div>
</div><p>The remaining exercises in this section are designed
to give you some more practice with conjunction and
bi-implication. Remember that a <em>partial order</em> is a
binary relation that is transitive, reflexive, and
antisymmetric.
An even weaker notion sometimes arises:
a <em>preorder</em> is just a reflexive, transitive relation.
For any pre-order <code class="docutils literal notranslate"><span class="pre">&#8804;</span></code>,
Lean axiomatizes the associated strict pre-order by
<code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">&lt;</span> <span class="pre">b</span> <span class="pre">&#8596;</span> <span class="pre">a</span> <span class="pre">&#8804;</span> <span class="pre">b</span> <span class="pre">&#8743;</span> <span class="pre">&#172;</span> <span class="pre">b</span> <span class="pre">&#8804;</span> <span class="pre">a</span></code>.
Show that if <code class="docutils literal notranslate"><span class="pre">&#8804;</span></code> is a partial order,
then <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">&lt;</span> <span class="pre">b</span></code> is equivalent to <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">&#8804;</span> <span class="pre">b</span> <span class="pre">&#8743;</span> <span class="pre">a</span> <span class="pre">&#8800;</span> <span class="pre">b</span></code>:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=import%20tactic%0A%0A--%20BEGIN%0Avariables%20%7B%CE%B1%20%3A%20Type*%7D%20%5Bpartial_order%20%CE%B1%5D%0Avariables%20a%20b%20%3A%20%CE%B1%0A%0Aexample%20%3A%20a%20%3C%20b%20%E2%86%94%20a%20%E2%89%A4%20b%20%E2%88%A7%20a%20%E2%89%A0%20b%20%3A%3D%0Abegin%0A%20%20rw%20lt_iff_le_not_le%2C%0A%20%20sorry%0Aend%0A--%20END" target="_blank" tryitfile="../examples/logic/unnamed_1734.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span class="kd">variables</span> <span class="o">{</span><span class="n">&#945;</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">partial_order</span> <span class="n">&#945;</span><span class="o">]</span>
<span class="kd">variables</span> <span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">&#945;</span>

<span class="kd">example</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">&lt;</span> <span class="n">b</span> <span class="bp">&#8596;</span> <span class="n">a</span> <span class="bp">&#8804;</span> <span class="n">b</span> <span class="bp">&#8743;</span> <span class="n">a</span> <span class="bp">&#8800;</span> <span class="n">b</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rw</span> <span class="n">lt_iff_le_not_le</span><span class="o">,</span>
  <span class="n">sorry</span>
<span class="kd">end</span>
</pre></div>
</div>
</div><p>Beyond logical operations, you should not need
anything more than <code class="docutils literal notranslate"><span class="pre">le_refl</span></code> and <code class="docutils literal notranslate"><span class="pre">le_antisymm</span></code>.
Then show that even in the case where <code class="docutils literal notranslate"><span class="pre">&#8804;</span></code>
is only assumed to be a preorder,
we can prove that the strict order is irreflexive
and transitive.
You do not need anything more than <code class="docutils literal notranslate"><span class="pre">le_refl</span></code> and <code class="docutils literal notranslate"><span class="pre">le_trans</span></code>.
In the second example,
for convenience, we use the simplifier rather than <code class="docutils literal notranslate"><span class="pre">rw</span></code>
to express <code class="docutils literal notranslate"><span class="pre">&lt;</span></code> in terms of <code class="docutils literal notranslate"><span class="pre">&#8804;</span></code> and <code class="docutils literal notranslate"><span class="pre">&#172;</span></code>
three times.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=import%20tactic%0A%0A--%20BEGIN%0Avariables%20%7B%CE%B1%20%3A%20Type*%7D%20%5Bpreorder%20%CE%B1%5D%0Avariables%20a%20b%20c%20%3A%20%CE%B1%0A%0Aexample%20%3A%20%C2%AC%20a%20%3C%20a%20%3A%3D%0Abegin%0A%20%20rw%20lt_iff_le_not_le%2C%0A%20%20sorry%0Aend%0A%0Aexample%20%3A%20a%20%3C%20b%20%E2%86%92%20b%20%3C%20c%20%E2%86%92%20a%20%3C%20c%20%3A%3D%0Abegin%0A%20%20simp%20only%20%5Blt_iff_le_not_le%5D%2C%0A%20%20sorry%0Aend%0A--%20END" target="_blank" tryitfile="../examples/logic/unnamed_1761.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span class="kd">variables</span> <span class="o">{</span><span class="n">&#945;</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">preorder</span> <span class="n">&#945;</span><span class="o">]</span>
<span class="kd">variables</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">:</span> <span class="n">&#945;</span>

<span class="kd">example</span> <span class="o">:</span> <span class="bp">&#172;</span> <span class="n">a</span> <span class="bp">&lt;</span> <span class="n">a</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rw</span> <span class="n">lt_iff_le_not_le</span><span class="o">,</span>
  <span class="n">sorry</span>
<span class="kd">end</span>

<span class="kd">example</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">&lt;</span> <span class="n">b</span> <span class="bp">&#8594;</span> <span class="n">b</span> <span class="bp">&lt;</span> <span class="n">c</span> <span class="bp">&#8594;</span> <span class="n">a</span> <span class="bp">&lt;</span> <span class="n">c</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">lt_iff_le_not_le</span><span class="o">],</span>
  <span class="n">sorry</span>
<span class="kd">end</span>
</pre></div>
</div>
</div></div>
<div class="section" id="disjunction">
<span id="id5"></span><h2><span class="section-number">3.5. </span>Disjunction<a class="headerlink" href="#disjunction" title="Permalink to this headline">&#182;</a></h2>
<p>The canonical way to prove a disjunction <code class="docutils literal notranslate"><span class="pre">A</span> <span class="pre">&#8744;</span> <span class="pre">B</span></code> is to prove
<code class="docutils literal notranslate"><span class="pre">A</span></code> or to prove <code class="docutils literal notranslate"><span class="pre">B</span></code>.
The <code class="docutils literal notranslate"><span class="pre">left</span></code> tactic chooses <code class="docutils literal notranslate"><span class="pre">A</span></code>,
and the <code class="docutils literal notranslate"><span class="pre">right</span></code> tactic chooses <code class="docutils literal notranslate"><span class="pre">B</span></code>.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=import%20data.real.basic%0A%0Avariables%20%7Bx%20y%20%3A%20%E2%84%9D%7D%0A%0A--%20BEGIN%0Aexample%20(h%20%3A%20y%20%3E%20x%5E2)%20%3A%20y%20%3E%200%20%E2%88%A8%20y%20%3C%20-1%20%3A%3D%0Aby%20%7B%20left%2C%20linarith%20%5Bpow_two_nonneg%20x%5D%20%7D%0A%0Aexample%20(h%20%3A%20-y%20%3E%20x%5E2%20%2B%201)%20%3A%20y%20%3E%200%20%E2%88%A8%20y%20%3C%20-1%20%3A%3D%0Aby%20%7B%20right%2C%20linarith%20%5Bpow_two_nonneg%20x%5D%20%7D%0A--%20END" target="_blank" tryitfile="../examples/logic/unnamed_1793.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span class="kd">example</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">y</span> <span class="bp">&gt;</span> <span class="n">x</span><span class="bp">^</span><span class="mi">2</span><span class="o">)</span> <span class="o">:</span> <span class="n">y</span> <span class="bp">&gt;</span> <span class="mi">0</span> <span class="bp">&#8744;</span> <span class="n">y</span> <span class="bp">&lt;</span> <span class="bp">-</span><span class="mi">1</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="o">{</span> <span class="n">left</span><span class="o">,</span> <span class="n">linarith</span> <span class="o">[</span><span class="n">pow_two_nonneg</span> <span class="n">x</span><span class="o">]</span> <span class="o">}</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">-</span><span class="n">y</span> <span class="bp">&gt;</span> <span class="n">x</span><span class="bp">^</span><span class="mi">2</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:</span> <span class="n">y</span> <span class="bp">&gt;</span> <span class="mi">0</span> <span class="bp">&#8744;</span> <span class="n">y</span> <span class="bp">&lt;</span> <span class="bp">-</span><span class="mi">1</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="o">{</span> <span class="n">right</span><span class="o">,</span> <span class="n">linarith</span> <span class="o">[</span><span class="n">pow_two_nonneg</span> <span class="n">x</span><span class="o">]</span> <span class="o">}</span>
</pre></div>
</div>
</div><p>We cannot use an anonymous constructor to construct a proof
of an &#8220;or&#8221; because Lean would have to guess
which disjunct we are trying to prove.
When we write proof terms we can use
<code class="docutils literal notranslate"><span class="pre">or.inl</span></code> and <code class="docutils literal notranslate"><span class="pre">or.inr</span></code> instead
to make the choice explicitly.
Here, <code class="docutils literal notranslate"><span class="pre">inl</span></code> is short for &#8220;insert left&#8221; and
<code class="docutils literal notranslate"><span class="pre">inr</span></code> is short for &#8220;insert right.&#8221;</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=import%20data.real.basic%0A%0Avariable%20%7By%20%3A%20%E2%84%9D%7D%0A%0A--%20BEGIN%0Aexample%20(h%20%3A%20y%20%3E%200)%20%3A%20y%20%3E%200%20%E2%88%A8%20y%20%3C%20-1%20%3A%3D%0Aor.inl%20h%0A%0Aexample%20(h%20%3A%20y%20%3C%20-1)%20%3A%20y%20%3E%200%20%E2%88%A8%20y%20%3C%20-1%20%3A%3D%0Aor.inr%20h%0A--%20END" target="_blank" tryitfile="../examples/logic/unnamed_1816.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span class="kd">example</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">y</span> <span class="bp">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">:</span> <span class="n">y</span> <span class="bp">&gt;</span> <span class="mi">0</span> <span class="bp">&#8744;</span> <span class="n">y</span> <span class="bp">&lt;</span> <span class="bp">-</span><span class="mi">1</span> <span class="o">:=</span>
<span class="n">or.inl</span> <span class="n">h</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">y</span> <span class="bp">&lt;</span> <span class="bp">-</span><span class="mi">1</span><span class="o">)</span> <span class="o">:</span> <span class="n">y</span> <span class="bp">&gt;</span> <span class="mi">0</span> <span class="bp">&#8744;</span> <span class="n">y</span> <span class="bp">&lt;</span> <span class="bp">-</span><span class="mi">1</span> <span class="o">:=</span>
<span class="n">or.inr</span> <span class="n">h</span>
</pre></div>
</div>
</div><p>It may seem strange to prove a disjunction by proving one side
or the other.
In practice, which case holds usually depends a case distinction
that is implicit or explicit in the assumptions and the data.
The <code class="docutils literal notranslate"><span class="pre">cases</span></code> tactic allows us to make use of a hypothesis
of the form <code class="docutils literal notranslate"><span class="pre">A</span> <span class="pre">&#8744;</span> <span class="pre">B</span></code>.
In contrast to the use of <code class="docutils literal notranslate"><span class="pre">cases</span></code> with conjunction or an
existential quantifier,
here the <code class="docutils literal notranslate"><span class="pre">cases</span></code> tactic produces <em>two</em> goals.
Both have the same conclusion, but in the first case,
<code class="docutils literal notranslate"><span class="pre">A</span></code> is assumed to be true,
and in the second case,
<code class="docutils literal notranslate"><span class="pre">B</span></code> is assumed to be true.
In other words, as the name suggests,
the <code class="docutils literal notranslate"><span class="pre">cases</span></code> tactic carries out a proof by cases.
As usual, we can tell Lean what names to use for the hypotheses.
In the next example, we tell Lean
to use the name <code class="docutils literal notranslate"><span class="pre">h</span></code> on each branch.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=import%20data.real.basic%0A%0Avariables%20%7Bx%20y%20%3A%20%E2%84%9D%7D%0A%0A--%20BEGIN%0Aexample%20%3A%20x%20%3C%20abs%20y%20%E2%86%92%20x%20%3C%20y%20%E2%88%A8%20x%20%3C%20-y%20%3A%3D%0Abegin%0A%20%20cases%20le_or_gt%200%20y%20with%20h%20h%2C%0A%20%20%7B%20rw%20abs_of_nonneg%20h%2C%0A%20%20%20%20intro%20h%2C%20left%2C%20exact%20h%20%7D%2C%0A%20%20rw%20abs_of_neg%20h%2C%0A%20%20intro%20h%2C%20right%2C%20exact%20h%0Aend%0A--%20END" target="_blank" tryitfile="../examples/logic/unnamed_1849.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span class="kd">example</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">&lt;</span> <span class="n">abs</span> <span class="n">y</span> <span class="bp">&#8594;</span> <span class="n">x</span> <span class="bp">&lt;</span> <span class="n">y</span> <span class="bp">&#8744;</span> <span class="n">x</span> <span class="bp">&lt;</span> <span class="bp">-</span><span class="n">y</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">cases</span> <span class="n">le_or_gt</span> <span class="mi">0</span> <span class="n">y</span> <span class="k">with</span> <span class="n">h</span> <span class="n">h</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">rw</span> <span class="n">abs_of_nonneg</span> <span class="n">h</span><span class="o">,</span>
    <span class="n">intro</span> <span class="n">h</span><span class="o">,</span> <span class="n">left</span><span class="o">,</span> <span class="n">exact</span> <span class="n">h</span> <span class="o">},</span>
  <span class="n">rw</span> <span class="n">abs_of_neg</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">intro</span> <span class="n">h</span><span class="o">,</span> <span class="n">right</span><span class="o">,</span> <span class="n">exact</span> <span class="n">h</span>
<span class="kd">end</span>
</pre></div>
</div>
</div><p>The absolute value function is defined in such a way
that we can immediately prove that
<code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">&#8805;</span> <span class="pre">0</span></code> implies <code class="docutils literal notranslate"><span class="pre">abs</span> <span class="pre">x</span> <span class="pre">=</span> <span class="pre">x</span></code>
(this is the theorem <code class="docutils literal notranslate"><span class="pre">abs_of_nonneg</span></code>)
and <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">&lt;</span> <span class="pre">0</span></code> implies <code class="docutils literal notranslate"><span class="pre">abs</span> <span class="pre">x</span> <span class="pre">=</span> <span class="pre">-x</span></code> (this is <code class="docutils literal notranslate"><span class="pre">abs_of_neg</span></code>).
The expression <code class="docutils literal notranslate"><span class="pre">le_or_gt</span> <span class="pre">0</span> <span class="pre">x</span></code> establishes <code class="docutils literal notranslate"><span class="pre">0</span> <span class="pre">&#8804;</span> <span class="pre">x</span> <span class="pre">&#8744;</span> <span class="pre">x</span> <span class="pre">&lt;</span> <span class="pre">0</span></code>,
allowing us to split on those two cases.
Try proving the triangle inequality using the two
first two theorems in the next snippet.
They are given the same names they have in mathlib.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=import%20data.real.basic%0A%0Avariables%20%7Bx%20y%20%3A%20%E2%84%9D%7D%0A%0Anamespace%20my_abs%0A%0A--%20BEGIN%0Atheorem%20le_abs_self%20%3A%20x%20%E2%89%A4%20abs%20x%20%3A%3D%0Asorry%0A%0Atheorem%20neg_le_abs_self%20%3A%20-x%20%E2%89%A4%20abs%20x%20%3A%3D%0Asorry%0A%0Atheorem%20abs_add%20%3A%20abs%20(x%20%2B%20y)%20%E2%89%A4%20abs%20x%20%2B%20abs%20y%20%3A%3D%0Asorry%0A--%20END%0A%0Aend%20my_abs" target="_blank" tryitfile="../examples/logic/unnamed_1877.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span class="kd">theorem</span> <span class="n">le_abs_self</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">&#8804;</span> <span class="n">abs</span> <span class="n">x</span> <span class="o">:=</span>
<span class="n">sorry</span>

<span class="kd">theorem</span> <span class="n">neg_le_abs_self</span> <span class="o">:</span> <span class="bp">-</span><span class="n">x</span> <span class="bp">&#8804;</span> <span class="n">abs</span> <span class="n">x</span> <span class="o">:=</span>
<span class="n">sorry</span>

<span class="kd">theorem</span> <span class="n">abs_add</span> <span class="o">:</span> <span class="n">abs</span> <span class="o">(</span><span class="n">x</span> <span class="bp">+</span> <span class="n">y</span><span class="o">)</span> <span class="bp">&#8804;</span> <span class="n">abs</span> <span class="n">x</span> <span class="bp">+</span> <span class="n">abs</span> <span class="n">y</span> <span class="o">:=</span>
<span class="n">sorry</span>
</pre></div>
</div>
</div><p>In case you enjoyed these (pun intended) and
you want more practice with disjunction,
try these.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=import%20data.real.basic%0A%0Avariables%20%7Bx%20y%20%3A%20%E2%84%9D%7D%0A%0Anamespace%20my_abs%0A%0A--%20BEGIN%0Atheorem%20lt_abs%20%3A%20x%20%3C%20abs%20y%20%E2%86%94%20x%20%3C%20y%20%E2%88%A8%20x%20%3C%20-y%20%3A%3D%0Asorry%0A%0Atheorem%20abs_lt%20%3A%20abs%20x%20%3C%20y%20%E2%86%94%20-%20y%20%3C%20x%20%E2%88%A7%20x%20%3C%20y%20%3A%3D%0Asorry%0A--%20END%0A%0Aend%20my_abs" target="_blank" tryitfile="../examples/logic/unnamed_1902.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span class="kd">theorem</span> <span class="n">lt_abs</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">&lt;</span> <span class="n">abs</span> <span class="n">y</span> <span class="bp">&#8596;</span> <span class="n">x</span> <span class="bp">&lt;</span> <span class="n">y</span> <span class="bp">&#8744;</span> <span class="n">x</span> <span class="bp">&lt;</span> <span class="bp">-</span><span class="n">y</span> <span class="o">:=</span>
<span class="n">sorry</span>

<span class="kd">theorem</span> <span class="n">abs_lt</span> <span class="o">:</span> <span class="n">abs</span> <span class="n">x</span> <span class="bp">&lt;</span> <span class="n">y</span> <span class="bp">&#8596;</span> <span class="bp">-</span> <span class="n">y</span> <span class="bp">&lt;</span> <span class="n">x</span> <span class="bp">&#8743;</span> <span class="n">x</span> <span class="bp">&lt;</span> <span class="n">y</span> <span class="o">:=</span>
<span class="n">sorry</span>
</pre></div>
</div>
</div><p>You can also use <code class="docutils literal notranslate"><span class="pre">rcases</span></code> and <code class="docutils literal notranslate"><span class="pre">rintros</span></code> with disjunctions.
When these result in a genuine case split with multiple goals,
the patterns for each new goal are separated by a vertical bar.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=import%20data.real.basic%0A%0A--%20BEGIN%0Aexample%20%7Bx%20%3A%20%E2%84%9D%7D%20(h%20%3A%20x%20%E2%89%A0%200)%20%3A%20x%20%3C%200%20%E2%88%A8%20x%20%3E%200%20%3A%3D%0Abegin%0A%20%20rcases%20lt_trichotomy%20x%200%20with%20xlt%20%7C%20xeq%20%7C%20xgt%2C%0A%20%20%7B%20left%2C%20exact%20xlt%20%7D%2C%0A%20%20%7B%20contradiction%20%7D%2C%0A%20%20right%2C%20exact%20xgt%0Aend%0A--%20END" target="_blank" tryitfile="../examples/logic/unnamed_1924.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span class="kd">example</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">&#8477;</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">&#8800;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">&lt;</span> <span class="mi">0</span> <span class="bp">&#8744;</span> <span class="n">x</span> <span class="bp">&gt;</span> <span class="mi">0</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rcases</span> <span class="n">lt_trichotomy</span> <span class="n">x</span> <span class="mi">0</span> <span class="k">with</span> <span class="n">xlt</span> <span class="bp">|</span> <span class="n">xeq</span> <span class="bp">|</span> <span class="n">xgt</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">left</span><span class="o">,</span> <span class="n">exact</span> <span class="n">xlt</span> <span class="o">},</span>
  <span class="o">{</span> <span class="n">contradiction</span> <span class="o">},</span>
  <span class="n">right</span><span class="o">,</span> <span class="n">exact</span> <span class="n">xgt</span>
<span class="kd">end</span>
</pre></div>
</div>
</div><p>You can still nest patterns and use the <code class="docutils literal notranslate"><span class="pre">rfl</span></code> keyword
to substitute equations:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=import%20tactic%0A%0A--%20BEGIN%0Aexample%20%7Bm%20n%20k%20%3A%20%E2%84%95%7D%20(h%20%3A%20m%20%E2%88%A3%20n%20%E2%88%A8%20m%20%E2%88%A3%20k)%20%3A%20m%20%E2%88%A3%20n%20*%20k%20%3A%3D%0Abegin%0A%20%20rcases%20h%20with%20%E2%9F%A8a%2C%20rfl%E2%9F%A9%20%7C%20%E2%9F%A8b%2C%20rfl%E2%9F%A9%2C%0A%20%20%7B%20rw%20%5Bmul_assoc%5D%2C%0A%20%20%20%20apply%20dvd_mul_right%20%7D%2C%0A%20%20rw%20%5Bmul_comm%2C%20mul_assoc%5D%2C%0A%20%20apply%20dvd_mul_right%0Aend%0A--%20END" target="_blank" tryitfile="../examples/logic/unnamed_1941.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span class="kd">example</span> <span class="o">{</span><span class="n">m</span> <span class="n">n</span> <span class="n">k</span> <span class="o">:</span> <span class="n">&#8469;</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">m</span> <span class="bp">&#8739;</span> <span class="n">n</span> <span class="bp">&#8744;</span> <span class="n">m</span> <span class="bp">&#8739;</span> <span class="n">k</span><span class="o">)</span> <span class="o">:</span> <span class="n">m</span> <span class="bp">&#8739;</span> <span class="n">n</span> <span class="bp">*</span> <span class="n">k</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rcases</span> <span class="n">h</span> <span class="k">with</span> <span class="o">&#10216;</span><span class="n">a</span><span class="o">,</span> <span class="n">rfl</span><span class="o">&#10217;</span> <span class="bp">|</span> <span class="o">&#10216;</span><span class="n">b</span><span class="o">,</span> <span class="n">rfl</span><span class="o">&#10217;,</span>
  <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="n">mul_assoc</span><span class="o">],</span>
    <span class="n">apply</span> <span class="n">dvd_mul_right</span> <span class="o">},</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">mul_comm</span><span class="o">,</span> <span class="n">mul_assoc</span><span class="o">],</span>
  <span class="n">apply</span> <span class="n">dvd_mul_right</span>
<span class="kd">end</span>
</pre></div>
</div>
</div><p>See if you can prove the following with a single (long) line.
Use <code class="docutils literal notranslate"><span class="pre">rcases</span></code> to unpack the hypotheses and split on cases,
and use a semicolon and <code class="docutils literal notranslate"><span class="pre">linarith</span></code> to solve each branch.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=import%20data.real.basic%0A%0A--%20BEGIN%0Aexample%20%7Bz%20%3A%20%E2%84%9D%7D%20(h%20%3A%20%E2%88%83%20x%20y%2C%20z%20%3D%20x%5E2%20%2B%20y%5E2%20%E2%88%A8%20z%20%3D%20x%5E2%20%2B%20y%5E2%20%2B%201)%20%3A%0A%20%20z%20%E2%89%A5%200%20%3A%3D%0Asorry%0A--%20END" target="_blank" tryitfile="../examples/logic/unnamed_1960.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span class="kd">example</span> <span class="o">{</span><span class="n">z</span> <span class="o">:</span> <span class="n">&#8477;</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">&#8707;</span> <span class="n">x</span> <span class="n">y</span><span class="o">,</span> <span class="n">z</span> <span class="bp">=</span> <span class="n">x</span><span class="bp">^</span><span class="mi">2</span> <span class="bp">+</span> <span class="n">y</span><span class="bp">^</span><span class="mi">2</span> <span class="bp">&#8744;</span> <span class="n">z</span> <span class="bp">=</span> <span class="n">x</span><span class="bp">^</span><span class="mi">2</span> <span class="bp">+</span> <span class="n">y</span><span class="bp">^</span><span class="mi">2</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">z</span> <span class="bp">&#8805;</span> <span class="mi">0</span> <span class="o">:=</span>
<span class="n">sorry</span>
</pre></div>
</div>
</div><p>On the real numbers, an equation <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">*</span> <span class="pre">y</span> <span class="pre">=</span> <span class="pre">0</span></code>
tells us that <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">0</span></code> or <code class="docutils literal notranslate"><span class="pre">y</span> <span class="pre">=</span> <span class="pre">0</span></code>.
In mathlib, this fact is known as <code class="docutils literal notranslate"><span class="pre">eq_zero_or_eq_zero_of_mul_eq_zero</span></code>,
and it is another nice example of how a disjunction can arise.
See if you can use it to prove the following:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=import%20data.real.basic%0A%0Avariables%20(x%20y%20%3A%20%E2%84%9D)%0A%0A--%20BEGIN%0Aexample%20(h%20%3A%20x%5E2%20%3D%201)%20%3A%20x%20%3D%201%20%E2%88%A8%20x%20%3D%20-1%20%3A%3D%0Asorry%0A%0Aexample%20(h%20%3A%20x%5E2%20%3D%20y%5E2)%20%3A%20x%20%3D%20y%20%E2%88%A8%20x%20%3D%20-y%20%3A%3D%0Asorry%0A--%20END" target="_blank" tryitfile="../examples/logic/unnamed_1976.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span class="kd">example</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">x</span><span class="bp">^</span><span class="mi">2</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">=</span> <span class="mi">1</span> <span class="bp">&#8744;</span> <span class="n">x</span> <span class="bp">=</span> <span class="bp">-</span><span class="mi">1</span> <span class="o">:=</span>
<span class="n">sorry</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">x</span><span class="bp">^</span><span class="mi">2</span> <span class="bp">=</span> <span class="n">y</span><span class="bp">^</span><span class="mi">2</span><span class="o">)</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">y</span> <span class="bp">&#8744;</span> <span class="n">x</span> <span class="bp">=</span> <span class="bp">-</span><span class="n">y</span> <span class="o">:=</span>
<span class="n">sorry</span>
</pre></div>
</div>
</div><p>Remember that you can use the <code class="docutils literal notranslate"><span class="pre">ring</span></code> tactic to help
with calculations.</p>
<p>In an arbitrary ring <span class="math notranslate nohighlight">\(R\)</span>, an element <span class="math notranslate nohighlight">\(x\)</span> such
that <span class="math notranslate nohighlight">\(x y = 0\)</span> for some nonzero <span class="math notranslate nohighlight">\(y\)</span> is called
a <em>left zero divisor</em>,
an element <span class="math notranslate nohighlight">\(x\)</span> such
that <span class="math notranslate nohighlight">\(y x = 0\)</span> for some nonzero <span class="math notranslate nohighlight">\(y\)</span> is called
a <em>right zero divisor</em>,
and an element that is either a left or right zero divisor
is called simply a <em>zero divisor</em>.
The theorem <code class="docutils literal notranslate"><span class="pre">eq_zero_or_eq_zero_of_mul_eq_zero</span></code>
says that the real numbers have no nontrivial zero divisors.
A commutative ring with this property is called an <em>integral domain</em>.
Your proofs of the two theorems above should work equally well
in any integral domain:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=import%20algebra.group_power%20tactic%0A%0Avariables%20%7BR%20%3A%20Type*%7D%20%5Bintegral_domain%20R%5D%0A%0Avariables%20(x%20y%20%3A%20R)%0A%0Aexample%20(h%20%3A%20x%5E2%20%3D%201)%20%3A%20x%20%3D%201%20%E2%88%A8%20x%20%3D%20-1%20%3A%3D%0Asorry%0A%0Aexample%20(h%20%3A%20x%5E2%20%3D%20y%5E2)%20%3A%20x%20%3D%20y%20%E2%88%A8%20x%20%3D%20-y%20%3A%3D%0Asorry" target="_blank" tryitfile="../examples/logic/unnamed_2007.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span class="kn">import</span> <span class="n">algebra.group_power</span> <span class="n">tactic</span>

<span class="kd">variables</span> <span class="o">{</span><span class="n">R</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">integral_domain</span> <span class="n">R</span><span class="o">]</span>

<span class="kd">variables</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">R</span><span class="o">)</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">x</span><span class="bp">^</span><span class="mi">2</span> <span class="bp">=</span> <span class="mi">1</span><span class="o">)</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">=</span> <span class="mi">1</span> <span class="bp">&#8744;</span> <span class="n">x</span> <span class="bp">=</span> <span class="bp">-</span><span class="mi">1</span> <span class="o">:=</span>
<span class="n">sorry</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">x</span><span class="bp">^</span><span class="mi">2</span> <span class="bp">=</span> <span class="n">y</span><span class="bp">^</span><span class="mi">2</span><span class="o">)</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">y</span> <span class="bp">&#8744;</span> <span class="n">x</span> <span class="bp">=</span> <span class="bp">-</span><span class="n">y</span> <span class="o">:=</span>
<span class="n">sorry</span>
</pre></div>
</div>
</div><p>In fact, if you are careful, you can prove the first
theorem without using commutativity of multiplication.
In that case, it suffices to assume that <code class="docutils literal notranslate"><span class="pre">R</span></code> is
a <code class="docutils literal notranslate"><span class="pre">domain</span></code> instead of an <code class="docutils literal notranslate"><span class="pre">integral_domain</span></code>.</p>
<p>Sometimes in a proof we want to split on cases
depending on whether some statement is true or not.
For any proposition <code class="docutils literal notranslate"><span class="pre">P</span></code>, we can use
<code class="docutils literal notranslate"><span class="pre">classical.em</span> <span class="pre">P</span> <span class="pre">:</span> <span class="pre">P</span> <span class="pre">&#8744;</span> <span class="pre">&#172;</span> <span class="pre">P</span></code>.
The name <code class="docutils literal notranslate"><span class="pre">em</span></code> is short for &#8220;excluded middle.&#8221;</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=example%20(P%20%3A%20Prop)%20%3A%20%C2%AC%20%C2%AC%20P%20%E2%86%92%20P%20%3A%3D%0Abegin%0A%20%20intro%20h%2C%0A%20%20cases%20classical.em%20P%2C%0A%20%20%7B%20assumption%20%7D%2C%0A%20%20contradiction%0Aend" target="_blank" tryitfile="../examples/logic/unnamed_2032.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span class="kd">example</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:</span> <span class="bp">&#172;</span> <span class="bp">&#172;</span> <span class="n">P</span> <span class="bp">&#8594;</span> <span class="n">P</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">intro</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">cases</span> <span class="n">classical.em</span> <span class="n">P</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">assumption</span> <span class="o">},</span>
  <span class="n">contradiction</span>
<span class="kd">end</span>
</pre></div>
</div>
</div><p>You can shorten <code class="docutils literal notranslate"><span class="pre">classical.em</span></code> to <code class="docutils literal notranslate"><span class="pre">em</span></code>
by opening the <code class="docutils literal notranslate"><span class="pre">classical</span></code> namespace with the command
<code class="docutils literal notranslate"><span class="pre">open</span> <span class="pre">classical</span></code>.
Alternatively, you can use the <code class="docutils literal notranslate"><span class="pre">by_cases</span></code> tactic.
The <code class="docutils literal notranslate"><span class="pre">open_locale</span> <span class="pre">classical</span></code> command guarantees that Lean can
make implicit use of the law of the excluded middle.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=import%20tactic%0A%0Aopen_locale%20classical%0A%0Aexample%20(P%20%3A%20Prop)%20%3A%20%C2%AC%20%C2%AC%20P%20%E2%86%92%20P%20%3A%3D%0Abegin%0A%20%20intro%20h%2C%0A%20%20by_cases%20h'%20%3A%20P%2C%0A%20%20%7B%20assumption%20%7D%2C%0A%20%20contradiction%0Aend" target="_blank" tryitfile="../examples/logic/unnamed_2049.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span class="kn">import</span> <span class="n">tactic</span>

<span class="n">open_locale</span> <span class="n">classical</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:</span> <span class="bp">&#172;</span> <span class="bp">&#172;</span> <span class="n">P</span> <span class="bp">&#8594;</span> <span class="n">P</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">intro</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">by_cases</span> <span class="n">h&#39;</span> <span class="o">:</span> <span class="n">P</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">assumption</span> <span class="o">},</span>
  <span class="n">contradiction</span>
<span class="kd">end</span>
</pre></div>
</div>
</div><p>Notice that the <code class="docutils literal notranslate"><span class="pre">by_cases</span></code> tactic lets you
specify a label for the hypothesis that is
introduced in each branch,
in this case, <code class="docutils literal notranslate"><span class="pre">h'</span> <span class="pre">:</span> <span class="pre">P</span></code> in one and <code class="docutils literal notranslate"><span class="pre">h'</span> <span class="pre">:</span> <span class="pre">&#172;</span> <span class="pre">P</span></code>
in the other.
If you leave out the label,
Lean uses <code class="docutils literal notranslate"><span class="pre">h</span></code> by default.
Try proving the following equivalence,
using <code class="docutils literal notranslate"><span class="pre">by_cases</span></code> to establish one direction.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=import%20tactic%0A%0Aopen_locale%20classical%0A%0A--%20BEGIN%0Aexample%20(P%20Q%20%3A%20Prop)%20%3A%20(P%20%E2%86%92%20Q)%20%E2%86%94%20%C2%AC%20P%20%E2%88%A8%20Q%20%3A%3D%0Asorry%0A--%20END" target="_blank" tryitfile="../examples/logic/unnamed_2073.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span class="kd">example</span> <span class="o">(</span><span class="n">P</span> <span class="n">Q</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">P</span> <span class="bp">&#8594;</span> <span class="n">Q</span><span class="o">)</span> <span class="bp">&#8596;</span> <span class="bp">&#172;</span> <span class="n">P</span> <span class="bp">&#8744;</span> <span class="n">Q</span> <span class="o">:=</span>
<span class="n">sorry</span>
</pre></div>
</div>
</div></div>
<div class="section" id="sequences-and-convergence">
<span id="id6"></span><h2><span class="section-number">3.6. </span>Sequences and Convergence<a class="headerlink" href="#sequences-and-convergence" title="Permalink to this headline">&#182;</a></h2>
<p>We now have enough skills at our disposal to do some real mathematics.
In Lean, we can represent a sequence <span class="math notranslate nohighlight">\(s_0, s_1, s_2, \ldots\)</span> of
real numbers as a function <code class="docutils literal notranslate"><span class="pre">s</span> <span class="pre">:</span> <span class="pre">&#8469;</span> <span class="pre">&#8594;</span> <span class="pre">&#8477;</span></code>.
Such a sequence is said to <em>converge</em> to a number <span class="math notranslate nohighlight">\(a\)</span> if for every
<span class="math notranslate nohighlight">\(\varepsilon &gt; 0\)</span> there is a point beyond which the sequence
remains within <span class="math notranslate nohighlight">\(\varepsilon\)</span> of <span class="math notranslate nohighlight">\(a\)</span>,
that is, there is a number <span class="math notranslate nohighlight">\(N\)</span> such that for every
<span class="math notranslate nohighlight">\(n \ge N\)</span>, <span class="math notranslate nohighlight">\(| s_n - a | &lt; \varepsilon\)</span>.
In Lean, we can render this as follows:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=import%20data.real.basic%0A%0A--%20BEGIN%0Adef%20converges_to%20(s%20%3A%20%E2%84%95%20%E2%86%92%20%E2%84%9D)%20(a%20%3A%20%E2%84%9D)%20%3A%3D%0A%E2%88%80%20%CE%B5%20%3E%200%2C%20%E2%88%83%20N%2C%20%E2%88%80%20n%20%E2%89%A5%20N%2C%20abs%20(s%20n%20-%20a)%20%3C%20%CE%B5%0A--%20END" target="_blank" tryitfile="../examples/logic/unnamed_2100.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span class="kd">def</span> <span class="n">converges_to</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">&#8469;</span> <span class="bp">&#8594;</span> <span class="n">&#8477;</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">&#8477;</span><span class="o">)</span> <span class="o">:=</span>
<span class="bp">&#8704;</span> <span class="n">&#949;</span> <span class="bp">&gt;</span> <span class="mi">0</span><span class="o">,</span> <span class="bp">&#8707;</span> <span class="n">N</span><span class="o">,</span> <span class="bp">&#8704;</span> <span class="n">n</span> <span class="bp">&#8805;</span> <span class="n">N</span><span class="o">,</span> <span class="n">abs</span> <span class="o">(</span><span class="n">s</span> <span class="n">n</span> <span class="bp">-</span> <span class="n">a</span><span class="o">)</span> <span class="bp">&lt;</span> <span class="n">&#949;</span>
</pre></div>
</div>
</div><p>The notation <code class="docutils literal notranslate"><span class="pre">&#8704;</span> <span class="pre">&#949;</span> <span class="pre">&gt;</span> <span class="pre">0,</span> <span class="pre">...</span></code> is a convenient abbreviation
for <code class="docutils literal notranslate"><span class="pre">&#8704;</span> <span class="pre">&#949;,</span> <span class="pre">&#949;</span> <span class="pre">&gt;</span> <span class="pre">0</span> <span class="pre">&#8594;</span> <span class="pre">...</span></code>, and, similarly,
<code class="docutils literal notranslate"><span class="pre">&#8704;</span> <span class="pre">n</span> <span class="pre">&#8805;</span> <span class="pre">N,</span> <span class="pre">...</span></code> abbreviates <code class="docutils literal notranslate"><span class="pre">&#8704;</span> <span class="pre">n,</span> <span class="pre">n</span> <span class="pre">&#8805;</span> <span class="pre">N</span> <span class="pre">&#8594;</span>&#160; <span class="pre">...</span></code>.
And remember that <code class="docutils literal notranslate"><span class="pre">&#949;</span> <span class="pre">&gt;</span> <span class="pre">0</span></code>, in turn, is defined as <code class="docutils literal notranslate"><span class="pre">0</span> <span class="pre">&lt;</span> <span class="pre">&#949;</span></code>,
and <code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">&#8805;</span> <span class="pre">N</span></code> is defined as <code class="docutils literal notranslate"><span class="pre">N</span> <span class="pre">&#8804;</span> <span class="pre">n</span></code>.</p>
<p>In this section, we&#8217;ll establish some properties of convergence.
But first, we will discuss three tactics for working equality
that will prove useful.
The first, the <code class="docutils literal notranslate"><span class="pre">ext</span></code> tactic,
gives us a way of proving that two functions are equal.
Let <span class="math notranslate nohighlight">\(f(x) = x + 1\)</span> and <span class="math notranslate nohighlight">\(g(x) = 1 + x\)</span>
be functions from reals to reals.
Then, of course, <span class="math notranslate nohighlight">\(f = g\)</span>, because they return the same
value for every <span class="math notranslate nohighlight">\(x\)</span>.
The <code class="docutils literal notranslate"><span class="pre">ext</span></code> tactic enables us to prove an equation between functions
by proving that their values are the same
at all the values of their arguments.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=import%20data.real.basic%0A%0A--%20BEGIN%0Aexample%20%3A%20(%CE%BB%20x%20y%20%3A%20%E2%84%9D%2C%20(x%20%2B%20y)%5E2)%20%3D%20(%CE%BB%20x%20y%20%3A%20%E2%84%9D%2C%20x%5E2%20%2B%202*x*y%20%2B%20y%5E2)%20%3A%3D%0Aby%20%7B%20ext%2C%20ring%20%7D%0A--%20END" target="_blank" tryitfile="../examples/logic/unnamed_2128.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span class="kd">example</span> <span class="o">:</span> <span class="o">(</span><span class="bp">&#955;</span> <span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">&#8477;</span><span class="o">,</span> <span class="o">(</span><span class="n">x</span> <span class="bp">+</span> <span class="n">y</span><span class="o">)</span><span class="bp">^</span><span class="mi">2</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="bp">&#955;</span> <span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">&#8477;</span><span class="o">,</span> <span class="n">x</span><span class="bp">^</span><span class="mi">2</span> <span class="bp">+</span> <span class="mi">2</span><span class="bp">*</span><span class="n">x</span><span class="bp">*</span><span class="n">y</span> <span class="bp">+</span> <span class="n">y</span><span class="bp">^</span><span class="mi">2</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="o">{</span> <span class="n">ext</span><span class="o">,</span> <span class="n">ring</span> <span class="o">}</span>
</pre></div>
</div>
</div><p>The second tactic, the <code class="docutils literal notranslate"><span class="pre">congr</span></code> tactic,
allows us to prove an equation between two expressions
by reconciling the parts that are different:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=import%20data.real.basic%0A%0A--%20BEGIN%0Aexample%20(a%20b%20%3A%20%E2%84%9D)%20%3A%20abs%20a%20%3D%20abs%20(a%20-%20b%20%2B%20b)%20%3A%3D%0Aby%20%20%7B%20congr%2C%20ring%20%7D%0A--%20END" target="_blank" tryitfile="../examples/logic/unnamed_2141.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span class="kd">example</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">&#8477;</span><span class="o">)</span> <span class="o">:</span> <span class="n">abs</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">abs</span> <span class="o">(</span><span class="n">a</span> <span class="bp">-</span> <span class="n">b</span> <span class="bp">+</span> <span class="n">b</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">by</span>  <span class="o">{</span> <span class="n">congr</span><span class="o">,</span> <span class="n">ring</span> <span class="o">}</span>
</pre></div>
</div>
</div><p>Here the <code class="docutils literal notranslate"><span class="pre">congr</span></code> tactic peels off the <code class="docutils literal notranslate"><span class="pre">abs</span></code> on each side,
leaving us to prove <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">=</span> <span class="pre">a</span> <span class="pre">-</span> <span class="pre">b</span> <span class="pre">+</span> <span class="pre">b</span></code>.</p>
<p>Finally, the <code class="docutils literal notranslate"><span class="pre">convert</span></code> tactic is used to apply a theorem
to a goal when the conclusion of the theorem doesn&#8217;t quite match.
For example, suppose we want to prove <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">&lt;</span> <span class="pre">a</span> <span class="pre">*</span> <span class="pre">a</span></code> from <code class="docutils literal notranslate"><span class="pre">1</span> <span class="pre">&lt;</span> <span class="pre">a</span></code>.
A theorem in the library, <code class="docutils literal notranslate"><span class="pre">mul_lt_mul_right</span></code>,
will let us prove <code class="docutils literal notranslate"><span class="pre">1</span> <span class="pre">*</span> <span class="pre">a</span> <span class="pre">&lt;</span> <span class="pre">a</span> <span class="pre">*</span> <span class="pre">a</span></code>.
One possibility is to work backwards and rewrite the goal
so that it has that form.
Instead, the <code class="docutils literal notranslate"><span class="pre">convert</span></code> tactic lets us apply the theorem
as it is,
and leaves us with the task of proving the equations that
are needed to make the goal match.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=import%20data.real.basic%0A%0A--%20BEGIN%0Aexample%20%7Ba%20%3A%20%E2%84%9D%7D%20(h%20%3A%201%20%3C%20a)%20%3A%20a%20%3C%20a%20*%20a%20%3A%3D%0Abegin%0A%20%20convert%20(mul_lt_mul_right%20_).2%20h%2C%0A%20%20%7B%20rw%20%5Bone_mul%5D%20%7D%2C%0A%20%20exact%20lt_trans%20zero_lt_one%20h%0Aend%0A--%20END" target="_blank" tryitfile="../examples/logic/unnamed_2165.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span class="kd">example</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">&#8477;</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="mi">1</span> <span class="bp">&lt;</span> <span class="n">a</span><span class="o">)</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">&lt;</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">a</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">convert</span> <span class="o">(</span><span class="n">mul_lt_mul_right</span> <span class="n">_</span><span class="o">)</span><span class="bp">.</span><span class="mi">2</span> <span class="n">h</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">rw</span> <span class="o">[</span><span class="n">one_mul</span><span class="o">]</span> <span class="o">},</span>
  <span class="n">exact</span> <span class="n">lt_trans</span> <span class="n">zero_lt_one</span> <span class="n">h</span>
<span class="kd">end</span>
</pre></div>
</div>
</div><p>This example illustrates another useful trick: when we apply an
expression with an underscore
and Lean can&#8217;t fill it in for us automatically,
it simply leaves it for us as another goal.</p>
<p>The following shows that any constant sequence <span class="math notranslate nohighlight">\(a, a, a, \ldots\)</span>
converges.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=import%20data.real.basic%0A%0Adef%20converges_to%20(s%20%3A%20%E2%84%95%20%E2%86%92%20%E2%84%9D)%20(a%20%3A%20%E2%84%9D)%20%3A%3D%0A%E2%88%80%20%CE%B5%20%3E%200%2C%20%E2%88%83%20N%2C%20%E2%88%80%20n%20%E2%89%A5%20N%2C%20abs%20(s%20n%20-%20a)%20%3C%20%CE%B5%0A%0Avariable%20(a%20%3A%20%E2%84%9D)%0A%0A--%20BEGIN%0Atheorem%20converges_to_const%20%3A%20converges_to%20(%CE%BB%20x%20%3A%20%E2%84%95%2C%20a)%20a%20%3A%3D%0Abegin%0A%20%20intros%20%CE%B5%20%CE%B5pos%2C%0A%20%20use%200%2C%0A%20%20intros%20n%20nge%2C%20dsimp%2C%0A%20%20rw%20%5Bsub_self%2C%20abs_zero%5D%2C%0A%20%20apply%20%CE%B5pos%0Aend%0A--%20END" target="_blank" tryitfile="../examples/logic/unnamed_2186.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span class="kd">theorem</span> <span class="n">converges_to_const</span> <span class="o">:</span> <span class="n">converges_to</span> <span class="o">(</span><span class="bp">&#955;</span> <span class="n">x</span> <span class="o">:</span> <span class="n">&#8469;</span><span class="o">,</span> <span class="n">a</span><span class="o">)</span> <span class="n">a</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">intros</span> <span class="n">&#949;</span> <span class="n">&#949;pos</span><span class="o">,</span>
  <span class="n">use</span> <span class="mi">0</span><span class="o">,</span>
  <span class="n">intros</span> <span class="n">n</span> <span class="n">nge</span><span class="o">,</span> <span class="n">dsimp</span><span class="o">,</span>
  <span class="n">rw</span> <span class="o">[</span><span class="n">sub_self</span><span class="o">,</span> <span class="n">abs_zero</span><span class="o">],</span>
  <span class="n">apply</span> <span class="n">&#949;pos</span>
<span class="kd">end</span>
</pre></div>
</div>
</div><p>Lean has a tactic, <code class="docutils literal notranslate"><span class="pre">simp</span></code>, which can often save you the
trouble of carrying out steps like <code class="docutils literal notranslate"><span class="pre">rw</span> <span class="pre">[sub_self,</span> <span class="pre">abs_zero]</span></code>
by hand.
We will tell you more about it soon.</p>
<p>For a more interesting theorem, let&#8217;s show that if <code class="docutils literal notranslate"><span class="pre">s</span></code>
converges to <code class="docutils literal notranslate"><span class="pre">a</span></code> and <code class="docutils literal notranslate"><span class="pre">t</span></code> converges to <code class="docutils literal notranslate"><span class="pre">b</span></code>, then
<code class="docutils literal notranslate"><span class="pre">&#955;</span> <span class="pre">n,</span> <span class="pre">s</span> <span class="pre">n</span> <span class="pre">+</span> <span class="pre">t</span> <span class="pre">n</span></code> converges to <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">+</span> <span class="pre">b</span></code>.
It is helpful to have a clear pen-and-paper
proof in mind before you start writing a formal one.
Given <code class="docutils literal notranslate"><span class="pre">&#949;</span></code> greater than <code class="docutils literal notranslate"><span class="pre">0</span></code>,
the idea is to use the hypotheses to obtain an <code class="docutils literal notranslate"><span class="pre">Ns</span></code>
such that beyond that point, <code class="docutils literal notranslate"><span class="pre">s</span></code> is within <code class="docutils literal notranslate"><span class="pre">&#949;</span> <span class="pre">/</span> <span class="pre">2</span></code>
of <code class="docutils literal notranslate"><span class="pre">a</span></code>,
and an <code class="docutils literal notranslate"><span class="pre">Nt</span></code> such that beyond that point, <code class="docutils literal notranslate"><span class="pre">t</span></code> is within
<code class="docutils literal notranslate"><span class="pre">&#949;</span> <span class="pre">/</span> <span class="pre">2</span></code> of <code class="docutils literal notranslate"><span class="pre">b</span></code>.
Then, whenever <code class="docutils literal notranslate"><span class="pre">n</span></code> is greater than or equal to the
maximum of <code class="docutils literal notranslate"><span class="pre">Ns</span></code> and <code class="docutils literal notranslate"><span class="pre">Nt</span></code>,
the sequence <code class="docutils literal notranslate"><span class="pre">&#955;</span> <span class="pre">n,</span> <span class="pre">s</span> <span class="pre">n</span> <span class="pre">+</span> <span class="pre">t</span> <span class="pre">n</span></code> should be within <code class="docutils literal notranslate"><span class="pre">&#949;</span></code>
of <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">+</span> <span class="pre">b</span></code>.
The following example begins to implement this strategy.
See if you can finish it off.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=import%20data.real.basic%0A%0Adef%20converges_to%20(s%20%3A%20%E2%84%95%20%E2%86%92%20%E2%84%9D)%20(a%20%3A%20%E2%84%9D)%20%3A%3D%0A%E2%88%80%20%CE%B5%20%3E%200%2C%20%E2%88%83%20N%2C%20%E2%88%80%20n%20%E2%89%A5%20N%2C%20abs%20(s%20n%20-%20a)%20%3C%20%CE%B5%0A%0A--%20BEGIN%0Avariables%20%7Bs%20t%20%3A%20%E2%84%95%20%E2%86%92%20%E2%84%9D%7D%20%7Ba%20b%20%3A%20%E2%84%9D%7D%0A%0Atheorem%20converges_to_add%0A%20%20(cs%20%3A%20converges_to%20s%20a)%20(ct%20%3A%20converges_to%20t%20b)%3A%0Aconverges_to%20(%CE%BB%20n%2C%20s%20n%20%2B%20t%20n)%20(a%20%2B%20b)%20%3A%3D%0Abegin%0A%20%20intros%20%CE%B5%20%CE%B5pos%2C%20dsimp%2C%0A%20%20have%20%CE%B52pos%20%3A%200%20%3C%20%CE%B5%20%2F%202%2C%0A%20%20%7B%20linarith%20%7D%2C%0A%20%20cases%20cs%20(%CE%B5%20%2F%202)%20%CE%B52pos%20with%20Ns%20hs%2C%0A%20%20cases%20ct%20(%CE%B5%20%2F%202)%20%CE%B52pos%20with%20Nt%20ht%2C%0A%20%20use%20max%20Ns%20Nt%2C%0A%20%20sorry%0Aend%0A--%20END" target="_blank" tryitfile="../examples/logic/unnamed_2231.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span class="kd">variables</span> <span class="o">{</span><span class="n">s</span> <span class="n">t</span> <span class="o">:</span> <span class="n">&#8469;</span> <span class="bp">&#8594;</span> <span class="n">&#8477;</span><span class="o">}</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">&#8477;</span><span class="o">}</span>

<span class="kd">theorem</span> <span class="n">converges_to_add</span>
  <span class="o">(</span><span class="n">cs</span> <span class="o">:</span> <span class="n">converges_to</span> <span class="n">s</span> <span class="n">a</span><span class="o">)</span> <span class="o">(</span><span class="n">ct</span> <span class="o">:</span> <span class="n">converges_to</span> <span class="n">t</span> <span class="n">b</span><span class="o">):</span>
<span class="n">converges_to</span> <span class="o">(</span><span class="bp">&#955;</span> <span class="n">n</span><span class="o">,</span> <span class="n">s</span> <span class="n">n</span> <span class="bp">+</span> <span class="n">t</span> <span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="bp">+</span> <span class="n">b</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">intros</span> <span class="n">&#949;</span> <span class="n">&#949;pos</span><span class="o">,</span> <span class="n">dsimp</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">&#949;2pos</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">&#949;</span> <span class="bp">/</span> <span class="mi">2</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">linarith</span> <span class="o">},</span>
  <span class="n">cases</span> <span class="n">cs</span> <span class="o">(</span><span class="n">&#949;</span> <span class="bp">/</span> <span class="mi">2</span><span class="o">)</span> <span class="n">&#949;2pos</span> <span class="k">with</span> <span class="n">Ns</span> <span class="n">hs</span><span class="o">,</span>
  <span class="n">cases</span> <span class="n">ct</span> <span class="o">(</span><span class="n">&#949;</span> <span class="bp">/</span> <span class="mi">2</span><span class="o">)</span> <span class="n">&#949;2pos</span> <span class="k">with</span> <span class="n">Nt</span> <span class="n">ht</span><span class="o">,</span>
  <span class="n">use</span> <span class="n">max</span> <span class="n">Ns</span> <span class="n">Nt</span><span class="o">,</span>
  <span class="n">sorry</span>
<span class="kd">end</span>
</pre></div>
</div>
</div><p>As hints, you can use <code class="docutils literal notranslate"><span class="pre">le_of_max_le_left</span></code> and <code class="docutils literal notranslate"><span class="pre">le_of_max_le_right</span></code>,
and <code class="docutils literal notranslate"><span class="pre">norm_num</span></code> can prove <code class="docutils literal notranslate"><span class="pre">&#949;</span> <span class="pre">/</span> <span class="pre">2</span> <span class="pre">+</span> <span class="pre">&#949;</span> <span class="pre">/</span> <span class="pre">2</span> <span class="pre">=</span> <span class="pre">&#949;</span></code>.
Also, it is helpful to use the <code class="docutils literal notranslate"><span class="pre">congr</span></code> tactic to
show that <code class="docutils literal notranslate"><span class="pre">abs</span> <span class="pre">(s</span> <span class="pre">n</span> <span class="pre">+</span> <span class="pre">t</span> <span class="pre">n</span> <span class="pre">-</span> <span class="pre">(a</span> <span class="pre">+</span> <span class="pre">b))</span></code> is equal to
<code class="docutils literal notranslate"><span class="pre">abs</span> <span class="pre">((s</span> <span class="pre">n</span> <span class="pre">-</span> <span class="pre">a)</span> <span class="pre">+</span> <span class="pre">(t</span> <span class="pre">n</span> <span class="pre">-</span> <span class="pre">b)),</span></code>
since then you can use the triangle inequality.
Notice that we marked all the variables <code class="docutils literal notranslate"><span class="pre">s</span></code>, <code class="docutils literal notranslate"><span class="pre">t</span></code>, <code class="docutils literal notranslate"><span class="pre">a</span></code>, and <code class="docutils literal notranslate"><span class="pre">b</span></code>
implicit because they can be inferred from the hypotheses.</p>
<p>Proving the same theorem with multiplication in place
of addition is tricky.
We will get there by proving some auxiliary statements first.
See if you can also finish off the next proof,
which shows that if <code class="docutils literal notranslate"><span class="pre">s</span></code> converges to <code class="docutils literal notranslate"><span class="pre">a</span></code>,
then <code class="docutils literal notranslate"><span class="pre">&#955;</span> <span class="pre">n,</span> <span class="pre">c</span> <span class="pre">*</span> <span class="pre">s</span> <span class="pre">n</span></code> converges to <code class="docutils literal notranslate"><span class="pre">c</span> <span class="pre">*</span> <span class="pre">a</span></code>.
It is helpful to split into cases depending on whether <code class="docutils literal notranslate"><span class="pre">c</span></code>
is equal to zero or not.
We have taken care of the zero case,
and we have left you to prove the result with
the extra assumption that <code class="docutils literal notranslate"><span class="pre">c</span></code> is nonzero.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=import%20data.real.basic%0A%0Adef%20converges_to%20(s%20%3A%20%E2%84%95%20%E2%86%92%20%E2%84%9D)%20(a%20%3A%20%E2%84%9D)%20%3A%3D%0A%E2%88%80%20%CE%B5%20%3E%200%2C%20%E2%88%83%20N%2C%20%E2%88%80%20n%20%E2%89%A5%20N%2C%20abs%20(s%20n%20-%20a)%20%3C%20%CE%B5%0A%0Atheorem%20converges_to_const%20(a%20%3A%20%E2%84%9D)%20%3A%20converges_to%20(%CE%BB%20x%20%3A%20%E2%84%95%2C%20a)%20a%20%3A%3D%0Asorry%0A%0Avariables%20%7Bs%20%3A%20%E2%84%95%20%E2%86%92%20%E2%84%9D%7D%20%7Ba%20%3A%20%E2%84%9D%7D%0A%0A--%20BEGIN%0Atheorem%20converges_to_mul_const%0A%20%20%20%20%7Bc%20%3A%20%E2%84%9D%7D%20(cs%20%3A%20converges_to%20s%20a)%20%3A%0A%20%20converges_to%20(%CE%BB%20n%2C%20c%20*%20s%20n)%20(c%20*%20a)%20%3A%3D%0Abegin%0A%20%20by_cases%20h%20%3A%20c%20%3D%200%2C%0A%20%20%7B%20convert%20converges_to_const%200%2C%0A%20%20%20%20%7B%20ext%2C%20rw%20%5Bh%2C%20zero_mul%5D%20%7D%2C%0A%20%20%20%20rw%20%5Bh%2C%20zero_mul%5D%20%7D%2C%0A%20%20have%20acpos%20%3A%200%20%3C%20abs%20c%2C%0A%20%20%20%20from%20abs_pos_of_ne_zero%20h%2C%0A%20%20sorry%0Aend%0A--%20END" target="_blank" tryitfile="../examples/logic/unnamed_2276.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span class="kd">theorem</span> <span class="n">converges_to_mul_const</span>
    <span class="o">{</span><span class="n">c</span> <span class="o">:</span> <span class="n">&#8477;</span><span class="o">}</span> <span class="o">(</span><span class="n">cs</span> <span class="o">:</span> <span class="n">converges_to</span> <span class="n">s</span> <span class="n">a</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">converges_to</span> <span class="o">(</span><span class="bp">&#955;</span> <span class="n">n</span><span class="o">,</span> <span class="n">c</span> <span class="bp">*</span> <span class="n">s</span> <span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">c</span> <span class="bp">*</span> <span class="n">a</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">by_cases</span> <span class="n">h</span> <span class="o">:</span> <span class="n">c</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">convert</span> <span class="n">converges_to_const</span> <span class="mi">0</span><span class="o">,</span>
    <span class="o">{</span> <span class="n">ext</span><span class="o">,</span> <span class="n">rw</span> <span class="o">[</span><span class="n">h</span><span class="o">,</span> <span class="n">zero_mul</span><span class="o">]</span> <span class="o">},</span>
    <span class="n">rw</span> <span class="o">[</span><span class="n">h</span><span class="o">,</span> <span class="n">zero_mul</span><span class="o">]</span> <span class="o">},</span>
  <span class="k">have</span> <span class="n">acpos</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">abs</span> <span class="n">c</span><span class="o">,</span>
    <span class="k">from</span> <span class="n">abs_pos_of_ne_zero</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">sorry</span>
<span class="kd">end</span>
</pre></div>
</div>
</div><p>The next theorem is also independently interesting:
it shows that a convergent sequence is eventually bounded
in absolute value.
We have started you off; see if you can finish it.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=import%20data.real.basic%0A%0Adef%20converges_to%20(s%20%3A%20%E2%84%95%20%E2%86%92%20%E2%84%9D)%20(a%20%3A%20%E2%84%9D)%20%3A%3D%0A%E2%88%80%20%CE%B5%20%3E%200%2C%20%E2%88%83%20N%2C%20%E2%88%80%20n%20%E2%89%A5%20N%2C%20abs%20(s%20n%20-%20a)%20%3C%20%CE%B5%0A%0Avariables%20%7Bs%20%3A%20%E2%84%95%20%E2%86%92%20%E2%84%9D%7D%20%7Ba%20%3A%20%E2%84%9D%7D%0A%0A--%20BEGIN%0Atheorem%20exists_abs_le_of_converges_to%20(cs%20%3A%20converges_to%20s%20a)%20%3A%0A%20%20%E2%88%83%20N%20b%2C%20%E2%88%80%20n%2C%20N%20%E2%89%A4%20n%20%E2%86%92%20abs%20(s%20n)%20%3C%20b%20%3A%3D%0Abegin%0A%20%20cases%20cs%201%20zero_lt_one%20with%20N%20h%2C%0A%20%20use%20%5BN%2C%20abs%20a%20%2B%201%5D%2C%0A%20%20sorry%0Aend%0A--%20END" target="_blank" tryitfile="../examples/logic/unnamed_2308.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span class="kd">theorem</span> <span class="n">exists_abs_le_of_converges_to</span> <span class="o">(</span><span class="n">cs</span> <span class="o">:</span> <span class="n">converges_to</span> <span class="n">s</span> <span class="n">a</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">&#8707;</span> <span class="n">N</span> <span class="n">b</span><span class="o">,</span> <span class="bp">&#8704;</span> <span class="n">n</span><span class="o">,</span> <span class="n">N</span> <span class="bp">&#8804;</span> <span class="n">n</span> <span class="bp">&#8594;</span> <span class="n">abs</span> <span class="o">(</span><span class="n">s</span> <span class="n">n</span><span class="o">)</span> <span class="bp">&lt;</span> <span class="n">b</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">cases</span> <span class="n">cs</span> <span class="mi">1</span> <span class="n">zero_lt_one</span> <span class="k">with</span> <span class="n">N</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">use</span> <span class="o">[</span><span class="n">N</span><span class="o">,</span> <span class="n">abs</span> <span class="n">a</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">],</span>
  <span class="n">sorry</span>
<span class="kd">end</span>
</pre></div>
</div>
</div><p>In fact, the theorem could be strengthened to assert
that there is a bound <code class="docutils literal notranslate"><span class="pre">b</span></code> that holds for all values of <code class="docutils literal notranslate"><span class="pre">n</span></code>.
But this version is strong enough for our purposes,
and we will see at the end of this section that it
holds more generally.</p>
<p>The next lemma is auxiliary: we prove that if
<code class="docutils literal notranslate"><span class="pre">s</span></code> converges to <code class="docutils literal notranslate"><span class="pre">a</span></code> and <code class="docutils literal notranslate"><span class="pre">t</span></code> converges to <code class="docutils literal notranslate"><span class="pre">0</span></code>,
then <code class="docutils literal notranslate"><span class="pre">&#955;</span> <span class="pre">n,</span> <span class="pre">s</span> <span class="pre">n</span> <span class="pre">*</span> <span class="pre">t</span> <span class="pre">n</span></code> converges to <code class="docutils literal notranslate"><span class="pre">0</span></code>.
To do so, we use the previous theorem to find a <code class="docutils literal notranslate"><span class="pre">B</span></code>
that bounds <code class="docutils literal notranslate"><span class="pre">s</span></code> beyond some point <code class="docutils literal notranslate"><span class="pre">N&#8320;</span></code>.
See if you can understand the strategy we have outlined
and finish the proof.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=import%20data.real.basic%0A%0Adef%20converges_to%20(s%20%3A%20%E2%84%95%20%E2%86%92%20%E2%84%9D)%20(a%20%3A%20%E2%84%9D)%20%3A%3D%0A%E2%88%80%20%CE%B5%20%3E%200%2C%20%E2%88%83%20N%2C%20%E2%88%80%20n%20%E2%89%A5%20N%2C%20abs%20(s%20n%20-%20a)%20%3C%20%CE%B5%0A%0Avariables%20%7Bs%20t%20%3A%20%E2%84%95%20%E2%86%92%20%E2%84%9D%7D%20%7Ba%20%3A%20%E2%84%9D%7D%0A%0Atheorem%20exists_abs_le_of_converges_to%20(cs%20%3A%20converges_to%20s%20a)%20%3A%0A%20%20%E2%88%83%20N%20b%2C%20%E2%88%80%20n%2C%20N%20%E2%89%A4%20n%20%E2%86%92%20abs%20(s%20n)%20%3C%20b%20%3A%3D%0Asorry%0A%0A--%20BEGIN%0Alemma%20aux%20(cs%20%3A%20converges_to%20s%20a)%20(ct%20%3A%20converges_to%20t%200)%20%3A%0A%20%20converges_to%20(%CE%BB%20n%2C%20s%20n%20*%20t%20n)%200%20%3A%3D%0Abegin%0A%20%20intros%20%CE%B5%20%CE%B5pos%2C%20dsimp%2C%0A%20%20rcases%20exists_abs_le_of_converges_to%20cs%20with%20%E2%9F%A8N%E2%82%80%2C%20B%2C%20h%E2%82%80%E2%9F%A9%2C%0A%20%20have%20Bpos%20%3A%200%20%3C%20B%2C%0A%20%20%20%20from%20lt_of_le_of_lt%20(abs_nonneg%20_)%20(h%E2%82%80%20N%E2%82%80%20(le_refl%20_))%2C%0A%20%20have%20pos%E2%82%80%20%3A%20%CE%B5%20%2F%20B%20%3E%200%2C%0A%20%20%20%20from%20div_pos%20%CE%B5pos%20Bpos%2C%0A%20%20cases%20ct%20_%20pos%E2%82%80%20with%20N%E2%82%81%20h%E2%82%81%2C%0A%20%20sorry%0Aend%0A--%20END" target="_blank" tryitfile="../examples/logic/unnamed_2341.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span class="kd">lemma</span> <span class="n">aux</span> <span class="o">(</span><span class="n">cs</span> <span class="o">:</span> <span class="n">converges_to</span> <span class="n">s</span> <span class="n">a</span><span class="o">)</span> <span class="o">(</span><span class="n">ct</span> <span class="o">:</span> <span class="n">converges_to</span> <span class="n">t</span> <span class="mi">0</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">converges_to</span> <span class="o">(</span><span class="bp">&#955;</span> <span class="n">n</span><span class="o">,</span> <span class="n">s</span> <span class="n">n</span> <span class="bp">*</span> <span class="n">t</span> <span class="n">n</span><span class="o">)</span> <span class="mi">0</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">intros</span> <span class="n">&#949;</span> <span class="n">&#949;pos</span><span class="o">,</span> <span class="n">dsimp</span><span class="o">,</span>
  <span class="n">rcases</span> <span class="n">exists_abs_le_of_converges_to</span> <span class="n">cs</span> <span class="k">with</span> <span class="o">&#10216;</span><span class="n">N&#8320;</span><span class="o">,</span> <span class="n">B</span><span class="o">,</span> <span class="n">h&#8320;</span><span class="o">&#10217;,</span>
  <span class="k">have</span> <span class="n">Bpos</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">B</span><span class="o">,</span>
    <span class="k">from</span> <span class="n">lt_of_le_of_lt</span> <span class="o">(</span><span class="n">abs_nonneg</span> <span class="n">_</span><span class="o">)</span> <span class="o">(</span><span class="n">h&#8320;</span> <span class="n">N&#8320;</span> <span class="o">(</span><span class="n">le_refl</span> <span class="n">_</span><span class="o">)),</span>
  <span class="k">have</span> <span class="n">pos&#8320;</span> <span class="o">:</span> <span class="n">&#949;</span> <span class="bp">/</span> <span class="n">B</span> <span class="bp">&gt;</span> <span class="mi">0</span><span class="o">,</span>
    <span class="k">from</span> <span class="n">div_pos</span> <span class="n">&#949;pos</span> <span class="n">Bpos</span><span class="o">,</span>
  <span class="n">cases</span> <span class="n">ct</span> <span class="n">_</span> <span class="n">pos&#8320;</span> <span class="k">with</span> <span class="n">N&#8321;</span> <span class="n">h&#8321;</span><span class="o">,</span>
  <span class="n">sorry</span>
<span class="kd">end</span>
</pre></div>
</div>
</div><p>If you have made it this far, congratulations!
We are now within striking distance of our theorem.
The following proof finishes it off.</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=import%20data.real.basic%0A%0Adef%20converges_to%20(s%20%3A%20%E2%84%95%20%E2%86%92%20%E2%84%9D)%20(a%20%3A%20%E2%84%9D)%20%3A%3D%0A%E2%88%80%20%CE%B5%20%3E%200%2C%20%E2%88%83%20N%2C%20%E2%88%80%20n%20%E2%89%A5%20N%2C%20abs%20(s%20n%20-%20a)%20%3C%20%CE%B5%0A%0Atheorem%20converges_to_const%20(a%20%3A%20%E2%84%9D)%20%3A%20converges_to%20(%CE%BB%20x%20%3A%20%E2%84%95%2C%20a)%20a%20%3A%3D%0Asorry%0A%0Avariables%20%7Bs%20t%20%3A%20%E2%84%95%20%E2%86%92%20%E2%84%9D%7D%20%7Ba%20b%20%3A%20%E2%84%9D%7D%0A%0Atheorem%20converges_to_add%0A%20%20%20%20(cs%20%3A%20converges_to%20s%20a)%20(ct%20%3A%20converges_to%20t%20b)%3A%0A%20%20converges_to%20(%CE%BB%20n%2C%20s%20n%20%2B%20t%20n)%20(a%20%2B%20b)%20%3A%3D%0Asorry%0A%0Atheorem%20converges_to_mul_const%0A%20%20%20%20(c%20%3A%20%E2%84%9D)%20(cs%20%3A%20converges_to%20s%20a)%20%3A%0A%20%20converges_to%20(%CE%BB%20n%2C%20c%20*%20s%20n)%20(c%20*%20a)%20%3A%3D%0Asorry%0A%0Alemma%20aux%20(cs%20%3A%20converges_to%20s%20a)%20(ct%20%3A%20converges_to%20t%200)%20%3A%0A%20%20converges_to%20(%CE%BB%20n%2C%20s%20n%20*%20t%20n)%200%20%3A%3D%0Asorry%0A%0A--%20BEGIN%0Atheorem%20converges_to_mul%0A%20%20%20%20(cs%20%3A%20converges_to%20s%20a)%20(ct%20%3A%20converges_to%20t%20b)%3A%0A%20%20converges_to%20(%CE%BB%20n%2C%20s%20n%20*%20t%20n)%20(a%20*%20b)%20%3A%3D%0Abegin%0A%20%20have%20h%E2%82%81%20%3A%20converges_to%20(%CE%BB%20n%2C%20s%20n%20*%20(t%20n%20-%20b))%200%2C%0A%20%20%7B%20apply%20aux%20cs%2C%0A%20%20%20%20convert%20converges_to_add%20ct%20(converges_to_const%20(-b))%2C%0A%20%20%20%20ring%20%7D%2C%0A%20%20convert%20(converges_to_add%20h%E2%82%81%20(converges_to_mul_const%20b%20cs))%2C%0A%20%20%7B%20ext%2C%20ring%20%7D%2C%0A%20%20ring%0Aend%0A--%20END" target="_blank" tryitfile="../examples/logic/unnamed_2373.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span class="kd">theorem</span> <span class="n">converges_to_mul</span>
    <span class="o">(</span><span class="n">cs</span> <span class="o">:</span> <span class="n">converges_to</span> <span class="n">s</span> <span class="n">a</span><span class="o">)</span> <span class="o">(</span><span class="n">ct</span> <span class="o">:</span> <span class="n">converges_to</span> <span class="n">t</span> <span class="n">b</span><span class="o">):</span>
  <span class="n">converges_to</span> <span class="o">(</span><span class="bp">&#955;</span> <span class="n">n</span><span class="o">,</span> <span class="n">s</span> <span class="n">n</span> <span class="bp">*</span> <span class="n">t</span> <span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="bp">*</span> <span class="n">b</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="k">have</span> <span class="n">h&#8321;</span> <span class="o">:</span> <span class="n">converges_to</span> <span class="o">(</span><span class="bp">&#955;</span> <span class="n">n</span><span class="o">,</span> <span class="n">s</span> <span class="n">n</span> <span class="bp">*</span> <span class="o">(</span><span class="n">t</span> <span class="n">n</span> <span class="bp">-</span> <span class="n">b</span><span class="o">))</span> <span class="mi">0</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">apply</span> <span class="n">aux</span> <span class="n">cs</span><span class="o">,</span>
    <span class="n">convert</span> <span class="n">converges_to_add</span> <span class="n">ct</span> <span class="o">(</span><span class="n">converges_to_const</span> <span class="o">(</span><span class="bp">-</span><span class="n">b</span><span class="o">)),</span>
    <span class="n">ring</span> <span class="o">},</span>
  <span class="n">convert</span> <span class="o">(</span><span class="n">converges_to_add</span> <span class="n">h&#8321;</span> <span class="o">(</span><span class="n">converges_to_mul_const</span> <span class="n">b</span> <span class="n">cs</span><span class="o">)),</span>
  <span class="o">{</span> <span class="n">ext</span><span class="o">,</span> <span class="n">ring</span> <span class="o">},</span>
  <span class="n">ring</span>
<span class="kd">end</span>
</pre></div>
</div>
</div><p>For another challenging exercise,
try filling out the following sketch of a proof that limits
are unique.
(If you are feeling bold,
you can delete the proof sketch and try proving it from scratch.)</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=import%20data.real.basic%0A%0Adef%20converges_to%20(s%20%3A%20%E2%84%95%20%E2%86%92%20%E2%84%9D)%20(a%20%3A%20%E2%84%9D)%20%3A%3D%0A%E2%88%80%20%CE%B5%20%3E%200%2C%20%E2%88%83%20N%2C%20%E2%88%80%20n%20%E2%89%A5%20N%2C%20abs%20(s%20n%20-%20a)%20%3C%20%CE%B5%0A%0Aopen_locale%20classical%0A%0A--%20BEGIN%0Atheorem%20converges_to_unique%20%7Bs%20%3A%20%E2%84%95%20%E2%86%92%20%E2%84%9D%7D%20%7Ba%20b%20%3A%20%E2%84%9D%7D%0A%20%20%20%20(sa%20%3A%20converges_to%20s%20a)%20(sb%20%3A%20converges_to%20s%20b)%20%3A%0A%20%20a%20%3D%20b%20%3A%3D%0Abegin%0A%20%20by_contradiction%20abne%2C%0A%20%20have%20%3A%20abs%20(a%20-%20b)%20%3E%200%2C%0A%20%20%7B%20sorry%20%7D%2C%0A%20%20let%20%CE%B5%20%3A%3D%20abs%20(a%20-%20b)%20%2F%202%2C%0A%20%20have%20%CE%B5pos%20%3A%20%CE%B5%20%3E%200%2C%0A%20%20%7B%20change%20abs%20(a%20-%20b)%20%2F%202%20%3E%200%2C%20linarith%20%7D%2C%0A%20%20cases%20sa%20%CE%B5%20%CE%B5pos%20with%20Na%20hNa%2C%0A%20%20cases%20sb%20%CE%B5%20%CE%B5pos%20with%20Nb%20hNb%2C%0A%20%20let%20N%20%3A%3D%20max%20Na%20Nb%2C%0A%20%20have%20absa%20%3A%20abs%20(s%20N%20-%20a)%20%3C%20%CE%B5%2C%0A%20%20%7B%20sorry%20%7D%2C%0A%20%20have%20absb%20%3A%20abs%20(s%20N%20-%20b)%20%3C%20%CE%B5%2C%0A%20%20%7B%20sorry%20%7D%2C%0A%20%20have%20%3A%20abs%20(a%20-%20b)%20%3C%20abs%20(a%20-%20b)%2C%0A%20%20%7B%20sorry%20%7D%2C%0A%20%20exact%20lt_irrefl%20_%20this%0Aend%0A--%20END" target="_blank" tryitfile="../examples/logic/unnamed_2420.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span class="kd">theorem</span> <span class="n">converges_to_unique</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">&#8469;</span> <span class="bp">&#8594;</span> <span class="n">&#8477;</span><span class="o">}</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">&#8477;</span><span class="o">}</span>
    <span class="o">(</span><span class="n">sa</span> <span class="o">:</span> <span class="n">converges_to</span> <span class="n">s</span> <span class="n">a</span><span class="o">)</span> <span class="o">(</span><span class="n">sb</span> <span class="o">:</span> <span class="n">converges_to</span> <span class="n">s</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">a</span> <span class="bp">=</span> <span class="n">b</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">by_contradiction</span> <span class="n">abne</span><span class="o">,</span>
  <span class="k">have</span> <span class="o">:</span> <span class="n">abs</span> <span class="o">(</span><span class="n">a</span> <span class="bp">-</span> <span class="n">b</span><span class="o">)</span> <span class="bp">&gt;</span> <span class="mi">0</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">sorry</span> <span class="o">},</span>
  <span class="k">let</span> <span class="n">&#949;</span> <span class="o">:=</span> <span class="n">abs</span> <span class="o">(</span><span class="n">a</span> <span class="bp">-</span> <span class="n">b</span><span class="o">)</span> <span class="bp">/</span> <span class="mi">2</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">&#949;pos</span> <span class="o">:</span> <span class="n">&#949;</span> <span class="bp">&gt;</span> <span class="mi">0</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">change</span> <span class="n">abs</span> <span class="o">(</span><span class="n">a</span> <span class="bp">-</span> <span class="n">b</span><span class="o">)</span> <span class="bp">/</span> <span class="mi">2</span> <span class="bp">&gt;</span> <span class="mi">0</span><span class="o">,</span> <span class="n">linarith</span> <span class="o">},</span>
  <span class="n">cases</span> <span class="n">sa</span> <span class="n">&#949;</span> <span class="n">&#949;pos</span> <span class="k">with</span> <span class="n">Na</span> <span class="n">hNa</span><span class="o">,</span>
  <span class="n">cases</span> <span class="n">sb</span> <span class="n">&#949;</span> <span class="n">&#949;pos</span> <span class="k">with</span> <span class="n">Nb</span> <span class="n">hNb</span><span class="o">,</span>
  <span class="k">let</span> <span class="n">N</span> <span class="o">:=</span> <span class="n">max</span> <span class="n">Na</span> <span class="n">Nb</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">absa</span> <span class="o">:</span> <span class="n">abs</span> <span class="o">(</span><span class="n">s</span> <span class="n">N</span> <span class="bp">-</span> <span class="n">a</span><span class="o">)</span> <span class="bp">&lt;</span> <span class="n">&#949;</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">sorry</span> <span class="o">},</span>
  <span class="k">have</span> <span class="n">absb</span> <span class="o">:</span> <span class="n">abs</span> <span class="o">(</span><span class="n">s</span> <span class="n">N</span> <span class="bp">-</span> <span class="n">b</span><span class="o">)</span> <span class="bp">&lt;</span> <span class="n">&#949;</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">sorry</span> <span class="o">},</span>
  <span class="k">have</span> <span class="o">:</span> <span class="n">abs</span> <span class="o">(</span><span class="n">a</span> <span class="bp">-</span> <span class="n">b</span><span class="o">)</span> <span class="bp">&lt;</span> <span class="n">abs</span> <span class="o">(</span><span class="n">a</span> <span class="bp">-</span> <span class="n">b</span><span class="o">),</span>
  <span class="o">{</span> <span class="n">sorry</span> <span class="o">},</span>
  <span class="n">exact</span> <span class="n">lt_irrefl</span> <span class="n">_</span> <span class="n">this</span>
<span class="kd">end</span>
</pre></div>
</div>
</div><p>We close the section with the observation that our proofs can be generalized.
For example, the only properties that we have used of the
natural numbers is that their structure carries a partial order
with <code class="docutils literal notranslate"><span class="pre">min</span></code> and <code class="docutils literal notranslate"><span class="pre">max</span></code>.
You can check that everything still works if you replace <code class="docutils literal notranslate"><span class="pre">&#8469;</span></code>
everywhere by any linear order <code class="docutils literal notranslate"><span class="pre">&#945;</span></code>:</p>
<div style="position: relative">
<div style='position: absolute; right: 0; top: 0; padding: 1ex'><a href="https://leanprover-community.github.io/lean-web-editor/#code=import%20data.real.basic%0A%0A--%20BEGIN%0Avariables%20%7B%CE%B1%20%3A%20Type*%7D%20%5Blinear_order%20%CE%B1%5D%0A%0Adef%20converges_to%20(s%20%3A%20%CE%B1%20%E2%86%92%20%E2%84%9D)%20(a%20%3A%20%E2%84%9D)%20%3A%3D%0A%E2%88%80%20%CE%B5%20%3E%200%2C%20%E2%88%83%20N%2C%20%E2%88%80%20n%20%E2%89%A5%20N%2C%20abs%20(s%20n%20-%20a)%20%3C%20%CE%B5%0A--%20END" target="_blank" tryitfile="../examples/logic/unnamed_2496.lean">
try it!</a></div><div class="highlight-lean notranslate"><div class="highlight"><pre><span class="kd">variables</span> <span class="o">{</span><span class="n">&#945;</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">linear_order</span> <span class="n">&#945;</span><span class="o">]</span>

<span class="kd">def</span> <span class="n">converges_to</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">&#945;</span> <span class="bp">&#8594;</span> <span class="n">&#8477;</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">&#8477;</span><span class="o">)</span> <span class="o">:=</span>
<span class="bp">&#8704;</span> <span class="n">&#949;</span> <span class="bp">&gt;</span> <span class="mi">0</span><span class="o">,</span> <span class="bp">&#8707;</span> <span class="n">N</span><span class="o">,</span> <span class="bp">&#8704;</span> <span class="n">n</span> <span class="bp">&#8805;</span> <span class="n">N</span><span class="o">,</span> <span class="n">abs</span> <span class="o">(</span><span class="n">s</span> <span class="n">n</span> <span class="bp">-</span> <span class="n">a</span><span class="o">)</span> <span class="bp">&lt;</span> <span class="n">&#949;</span>
</pre></div>
</div>
</div><p>In a later chapter, we will see that mathlib has mechanisms
for dealing with convergence in vastly more general terms,
not only abstracting away particular features of the domain
and codomain,
but also abstracting over different types of convergence.</p>
</div>
</div>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="index.html">Mathematics in Lean</a></h1>








<!-- <h3>Navigation</h3> -->
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="introduction.html">1. Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="basics.html">2. Basics</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">3. Logic</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#implication-and-the-universal-quantifier">3.1. Implication and the Universal Quantifier</a></li>
<li class="toctree-l2"><a class="reference internal" href="#the-existential-quantifier">3.2. The Existential Quantifier</a></li>
<li class="toctree-l2"><a class="reference internal" href="#negation">3.3. Negation</a></li>
<li class="toctree-l2"><a class="reference internal" href="#conjunction-and-bi-implication">3.4. Conjunction and Bi-implication</a></li>
<li class="toctree-l2"><a class="reference internal" href="#disjunction">3.5. Disjunction</a></li>
<li class="toctree-l2"><a class="reference internal" href="#sequences-and-convergence">3.6. Sequences and Convergence</a></li>
</ul>
</li>
</ul>


<hr />
<ul>
    
    <li class="toctree-l1"><a href="mathematics_in_lean.pdf">PDF version</a></li>
    
    <li class="toctree-l1"><a href="https://leanprover.github.io/">Lean Home</a></li>
    
</ul>

<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2020, Jeremy Avigad, Kevin Buzzard, Robert Y. Lewis, Patrick Massot.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 3.0.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="_sources/logic.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>